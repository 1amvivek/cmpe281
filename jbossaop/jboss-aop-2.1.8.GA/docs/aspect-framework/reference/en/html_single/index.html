<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>JBoss AOP - Aspect-Oriented Framework for Java</title>
      <link rel="stylesheet" href="css/jbossorg.css" type="text/css"/>
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/>
   </head>
   <body>
      <div class="book" lang="en">
         <div class="titlepage">
            <div>
               <p id="title">
                  <a href="http://www.jboss.org" class="jbossOrg_href">
                     <strong>
						        JBoss.org	
						</strong>
                  </a>
                  <a href="http://labs.jboss.com/projects/docs" class="commDoc_href">
                     <strong>
						        Community Documentation	
						</strong>
                  </a>
               </p>
               <div>
                  <h1 class="title">
                     <a id="d0e1"/>JBoss AOP - Aspect-Oriented Framework for Java</h1>
               </div>
               <div>
                  <h2 class="subtitle">JBoss AOP Reference Documentation</h2>
               </div>
               <div>
                  <p class="releaseinfo">2.0.0</p>
               </div>
            </div>
            <hr/>
         </div>
         <div class="toc">
            <dl>
               <dt>
                  <span class="preface">
                     <a href="#preface">Preface</a>
                  </span>
               </dt>
               <dt>
                  <span class="chapter">
                     <a href="#terms">1. Terms</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#base-terms">1.1. Overview</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#implementing">2. Chapter 2</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-overview">2.1. Overview</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-aspect">2.2. Aspect Class</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-advice">2.3. Advice Methods</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-interceptor">2.4. Interceptors</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-invocation3">2.5. Resolving Annotations</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-invocation4">2.6. Metadata</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#impl-metadata1">2.6.1. Resolving XML Metadata</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#impl-metadata2">2.6.2. Attaching Metadata</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-mixin">2.7. Mixin Definition</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#impl-dyn-cflow">2.8. Dynamic CFlow</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#pointcuts">3. Joinpoint and Pointcut Expressions</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-wilcards">3.1. Wildcards</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-types">3.2. Type Patterns</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-method">3.3. Method Patterns</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-con">3.4. Constructor Patterns</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-field">3.5. Field Patterns</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-pointcut">3.6. Pointcuts</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-composition">3.7. Pointcut Composition</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-ref">3.8. Pointcut References</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-typedef">3.9. Typedef Expressions</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#pointcuts-joinpoints">3.10. Joinpoints</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#pointcuts-beans">3.10.1. Joinpoint Beans</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#pointcuts-contextvalues">3.10.2. Context Values</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#advices">4. Advices</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#adv-around">4.1. Around Advices</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#adv-batf">4.2. Before/After/After-Throwing/Finally Advices</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-beforesignature">4.2.1. Before Advice Signature</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-aftersignature">4.2.2. After Advice Signature</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-throwingsignature">4.2.3. After-Throwing Advice Signature</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-finallysignature">4.2.4. Finally Advice Signature</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#adv-annotatedparameters">4.3. Annotated Advice Parameters</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-thrown">4.3.1. @Thrown annotated parameter</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-joinpointargs">4.3.2. JoinPoint Arguments</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#adv-overloaded">4.4. Overloaded Advices</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-overlannotparam">4.4.1. Annotated-parameter Signature</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-overldefaultsignature">4.4.2. Default Signature</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#adv-overldiffsign">4.4.3. Mixing Different Signatures</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#adv-errors">4.5. Common Mistakes</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#xml">5. XML Bindings</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-overview">5.1. Intro</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-resolving">5.2. Resolving XML</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-resolving1">5.2.1. Standalone XML Resolving</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-resolving2">5.2.2. Application Server XML Resolving</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-schema">5.3. XML Schema</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-aspect">5.4. aspect</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-aspect1">5.4.1. Basic Definition</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-aspect2">5.4.2. Scope</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-aspect3">5.4.3. Configuration</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-aspect4">5.4.4. Aspect Factories</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-interceptor">5.5. interceptor</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-bind">5.6. bind</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-stack">5.7. stack</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-pointcut">5.8. pointcut</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-introduction">5.9. introduction</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-introduction1">5.9.1. Interface introductions</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#xml-introduction2">5.9.2. Mixins</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-annotation-introduction">5.10. annotation-introduction</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-cflow">5.11. cflow-stack</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-typedef">5.12. typedef</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-dynamic">5.13. dynamic-cflow</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-prepare">5.14. prepare</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-metadata">5.15. metadata</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-metadata-loader">5.16. metadata-loader</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-precedence">5.17. precedence</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#xml-declare">5.18. declare</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#declare-warning">5.18.1. declare-warning</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#declare-error">5.18.2. declare-error</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#annotated">6. Annotation Bindings</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-aspect">6.1. @Aspect</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-interceptor">6.2. @InterceptorDef</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#annotated-interceptor-interceptor">6.2.1. Interceptor Example</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#annotated-interceptor-factory">6.2.2. AspectFactory Example</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-pointcut">6.3. @PointcutDef</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-bind">6.4. @Bind</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-introduction">6.5. @Introduction</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-mixin">6.6. @Mixin</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-prepare">6.7. @Prepare</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#annotated-prepare-pojo">6.7.1. @Prepare POJO</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-typedef">6.8. @TypeDef</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-cflow">6.9. @CFlowDef</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-dynamiccflow">6.10. @DynamicCFlowDef</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-annotationintro">6.11. @AnnotationIntroductionDef</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-precedence">6.12. @Precedence</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#annotated-declare">6.13. @DeclareError and @DeclareWarning</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#dynamic">7. Dynamic AOP</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#dyn-1">7.1. Hot Deployment</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#dyn-2">7.2. Per Instance AOP</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#dyn-3">7.3. Preparation</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#dyn-4">7.4. Improved Instance API</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#dyn-5">7.5. DynamicAOP with HotSwap</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#installing">8. Installing</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#installing-standalone">8.1. Installing Standalone</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#installing-jboss40-jdk50">8.2. Installing with JBoss 4.0.x and JBoss 4.2.x Application Server for JDK 5</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#installing-jboss5-jdk5">8.3. Installing with JBoss Application Server 5</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#compiling">9. Building and Compiling Aspectized Java</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#modes">9.1. Instrumentation modes</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#ant">9.2. Ant Integration</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#commandline">9.3. Command Line</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#running">10. Running Aspectized Applications</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#d0e4263">10.1. Loadtime, Compiletime and HotSwap Modes</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#standalone">10.2. Regular Java Applications</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#standalone-compiletime">10.2.1. Precompiled instrumentation</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4355">10.2.2. Loadtime</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4502">10.2.3. HotSwap</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4548">10.2.4. User-Defined ClassLoaders</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#jboss">10.3. JBoss Application Server</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4567">10.3.1. Packaging AOP Applications</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4603">10.3.2. The JBoss AspectManager Service</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#running-as-sun-jdk">10.3.3. Loadtime transformation in JBoss AS Using Sun JDK</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4699">10.3.4. JBoss 5 and JRockit</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4752">10.3.5. Improving Loadtime Performance in a JBoss AS Environment</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#d0e4757">10.4. Scoping aop to the classloader</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4762">10.4.1. Deploying as part of a scoped classloader</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#d0e4767">10.4.2. Attaching to a scoped deployment</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#maven">11. Building JBoss AOP with Maven2</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#compiling_maven">11.1. AOP Compile with Maven2</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#compiletests">11.2. AOP Compile tests with Maven2</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#maven_running">11.3. Running precompiled with Maven2</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#runningweaving">11.4. Running loadtime weaving with Maven2</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#runningtests">11.5. Running tests with Maven2</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#reflection">12. Reflection and AOP</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#reflection-attach-chains">12.1. Force interception via reflection</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#reflection-cleaning">12.2. Clean results from reflection info methods</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#arrays">13. Interception of Array Element Access</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#array-replacement">13.1. Replacing Array Access</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#array-preparing">13.2. Preparing Array Fields</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#array-binding">13.3. Binding Advices to array element access</a>
                        </span>
                     </dt>
                     <dt>
                        <span class="sect1">
                           <a href="#array-invocations">13.4. Invocation types for array element access interception</a>
                        </span>
                     </dt>
                  </dl>
               </dd>
               <dt>
                  <span class="chapter">
                     <a href="#insrumentation-modes">14. Instrumentation Modes</a>
                  </span>
               </dt>
               <dd>
                  <dl>
                     <dt>
                        <span class="sect1">
                           <a href="#instrumention-modes-classic">14.1. Classic Weaving</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#instrumentation-modes-classic-not-optimized">14.1.1. Non-optimized</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#instrumentation-modes-classic-optimized">14.1.2. Optimized</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                     <dt>
                        <span class="sect1">
                           <a href="#instrumention-modes-generated-advisor">14.2. Generated Advisor Weaving</a>
                        </span>
                     </dt>
                     <dd>
                        <dl>
                           <dt>
                              <span class="sect2">
                                 <a href="#instrumention-modes-generated-advisor-batf">14.2.1. Lightweight Aspects</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#instrumention-modes-generated-advisor-instance-api">14.2.2. Improved Instance API</a>
                              </span>
                           </dt>
                           <dt>
                              <span class="sect2">
                                 <a href="#instrumention-modes-generated-advisor-chain-overriding">14.2.3. Chain Overriding of Inherited Methods</a>
                              </span>
                           </dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
            </dl>
         </div>
         <div class="preface" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="preface"/>Preface</h2>
                  </div>
               </div>
            </div>
            <p>
            Aspect-Oriented Programming (AOP) is a new  paradigm that allows you to organize
            and layer your software applications in ways that are impossible with traditional
            object-oriented approaches.  Aspects allow you to transparently glue functionality together
            so that you can have a more layered design.  AOP allows you to intercept any event in a Java
            program and trigger functionality based on those events.  Mixins allow you to introduce
            multiple inheritance to Java so that you can provide APIs for your aspects.  Combined with 
            annotations, it allows you to extend the Java language with new syntax.
      </p>
            <p>
            JBoss AOP is a 100% Pure Java aspected oriented framework usable in any programming 
            environment or tightly integrated with  our application server.
      </p>
            <p>
            This document is meant to be a boring reference guide.  It focuses solely on syntax and APIs
            and worries less about providing real world examples. Please see our "User Guide: The Case for Aspects"
            document for a more interesting discussion on the use of aspects.
      </p>
            <p>
             If you have questions, use the user forum linked on the JBoss AOP website. We also
             provide tracking links for tracking bug reports and feature requests. If you
             are interested in the development of JBoss AOP, post a message on the forum. If
             you are interested in translating this documentation into your language, contact us
             on the developer mailing list.
      </p>
            <p>
             Commercial development support, production support and training for JBoss AOP is
             available through JBoss Inc. (see http://www.jboss.org/).
             JBoss AOP is a project of the JBoss Professional Open Source product suite.
      </p>
            <p>
         In some of the example listings, what is meant to be displayed on one line does not fit 
         inside the available page width. These lines have been broken up. A '\' at the end of a 
         line means that a break has been introduced to fit in the page, with the following lines
         indented. So:
         </p>
            <pre class="programlisting">
   Let's pretend to have an extremely \
      long line that \
      does not fit
   This one is short
         </pre>
            <p>
         Is really:
         </p>
            <pre class="programlisting">
   Let's pretend to have an extremely long line that does not fit
   This one is short
         </pre>
            <p>
      
            </p>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="terms"/>Chapter 1. Terms</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#base-terms">1.1. Overview</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="base-terms"/>1.1. Overview</h2>
                     </div>
                  </div>
               </div>
               <p>
            The section defines some basic terms that will be used throughout this guide.
      </p>
               <p>

         
               </p>
               <div class="variablelist">
                  <dl>
                     <dt>
                        <span class="term">Joinpoint</span>
                     </dt>
                     <dd>
                        <p>
                     A joinpoint is any point in your java program.  The call of a method.  The execution of a constructor
                     the access of a field.  All these are joinpoints.  You could also think of a joinpoint as a particular
                     Java event.  Where an event is a method call, constructor call, field access etc...
                  </p>
                     </dd>
                     <dt>
                        <span class="term">Invocation</span>
                     </dt>
                     <dd>
                        <p>
                     An Invocation is a JBoss AOP class that encapsulates what a joinpiont is at runtime.  It could
                     contain information like which method is being called, the arguments of the method, etc...
                  </p>
                     </dd>
                     <dt>
                        <span class="term">Advice</span>
                     </dt>
                     <dd>
                        <p>
                     An advice is a method that is called when a particular joinpoint is executed, i.e., the behavior
                     that is triggered when a method is called.  It could also be thought of as the code that does the
                     interception.  Another analogy is that an advice is an "event handler".
                  </p>
                     </dd>
                     <dt>
                        <span class="term">Pointcut</span>
                     </dt>
                     <dd>
                        <p>
                     Pointcuts are AOP's expression language.  Just as a regular expression matches strings, a pointcut
                     expression matches a particular joinpoint.
                  </p>
                     </dd>
                     <dt>
                        <span class="term">Introductions</span>
                     </dt>
                     <dd>
                        <p>
                     An introduction modifies the type and structure of a Java class.  It can be used to force
                     an existing class to implement an interface or to add an annotation to anything.
                  </p>
                     </dd>
                     <dt>
                        <span class="term">Aspect</span>
                     </dt>
                     <dd>
                        <p>
                     An Aspect is a plain Java class that encapsulates any number of advices, pointcut definitions,
                     mixins, or any other JBoss AOP construct.
                  </p>
                     </dd>
                     <dt>
                        <span class="term">Interceptor</span>
                     </dt>
                     <dd>
                        <p>
                     An interceptor is an Aspect with only one advice named "invoke".  It is a specific interface
                     that you can implement if you want your code to be checked by forcing your class to implement an interface.
                     It also will be portable and can be reused in other JBoss environments like EJBs and JMX MBeans.
                  </p>
                     </dd>
                  </dl>
               </div>
               <p>
      
               </p>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="implementing"/>Chapter 2. Implementing Aspects</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-overview">2.1. Overview</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-aspect">2.2. Aspect Class</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-advice">2.3. Advice Methods</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-interceptor">2.4. Interceptors</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-invocation3">2.5. Resolving Annotations</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-invocation4">2.6. Metadata</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#impl-metadata1">2.6.1. Resolving XML Metadata</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#impl-metadata2">2.6.2. Attaching Metadata</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-mixin">2.7. Mixin Definition</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#impl-dyn-cflow">2.8. Dynamic CFlow</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-overview"/>2.1. Overview</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AOP is a 100% pure Java framework.  All your AOP constructs are defined as pure Java classes and
         bound to your application code via XML or by annotations.  This Chapter walks through implementing aspects.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-aspect"/>2.2. Aspect Class</h2>
                     </div>
                  </div>
               </div>
               <p>
         The Aspect Class is a plain Java class that can define zero or more advices, pointcuts, and/or mixins.
      </p>
               <pre class="programlisting">public class Aspect
 {
   public Object trace(Invocation invocation) throws Throwable {
      try {
         System.out.println("Entering anything");
         return invocation.invokeNext(); // proceed to next advice or actual call
      } finally {
         System.out.println("Leaving anything");
      }
   }
}</pre>
               <p>
         The example above is of an advice
         <code class="literal">trace</code> that traces calls to any type of joinpoint.
         Notice that <code class="literal">Invocation</code> objects are the runtime encapsulation of joinpoints.
         The method <code class="literal">invocation.invokeNext()</code> is used to drive the advice chain.  It either calls
         the next advice in the chain, or does the actual method or constructor invocation.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-advice"/>2.3. Advice Methods</h2>
                     </div>
                  </div>
               </div>
               <p>
           For basic interception, any method that follows the form:
      </p>
               <pre class="programlisting">Object methodName(Invocation object) throws Throwable</pre>
               <p>
           can be an advice.  The
         <code class="literal">Invocation.invokeNext()</code> method must be called by the advice
           code or no other advice will be called, and the actual method, field, or constructor invocation will not
           happen.
      </p>
               <p>
          JBoss AOP provides five types of advice: before, around, after, finally and after-throwing.
         The advice sginature above is the default one for an around advice. Advices types,
         signature rules and overloading will be covered in <a href="#advices" title="Chapter 4. Advices">Chapter 4, <i xmlns:xlink="http://www.w3.org/1999/xlink">Advices</i>
                  </a>.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-interceptor"/>2.4. Interceptors</h2>
                     </div>
                  </div>
               </div>
               <p>
         Interceptors are a special type of aspect that contains only one advice. This advice has its
         signature defined by an interface, <code class="literal">org.jboss.aop.advice.Interceptor</code>:
      </p>
               <pre class="programlisting">public interface Interceptor
{
   public String getName();
   
   public Object invoke(Invocation invocation) throws Throwable;
}</pre>
               <p>
         The method <code class="literal">invoke(Invocation)</code> is the unique advice contained in an interceptor.
         The method <code class="literal">getName()</code> is used for identification in the JBoss AOP framework.
         So, this method must return a name that is unique in the whole system. It is only really used for
         aspects added to the <code class="literal">InstanceAdvisor</code> as shown in <a href="#dyn-2" title="7.2. Per Instance AOP">Section 7.2, “Per Instance AOP”</a>.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-invocation3"/>2.5. Resolving Annotations</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AOP provides an abstraction for resolving annotations. 
         In future versions of JBoss AOP, there will be a way to override annotation values on a
         per thread basis, or via XML overrides, or even provide VM and cluster wide defaults for annotation values.
         Also if you want to write a truly generic advice that takes the base Invocation type, you can still get the
         annotation value of the method, constructor, or field you're invoking on by calling this method:
      </p>
               <pre class="programlisting">Object resolveAnnotation(Class annotation);</pre>
               <p>
         That's just resolving for resolving member annotations.  If your aspect needs to resolve class level annotations
         then this method should be called:
      </p>
               <pre class="programlisting">Object resolveClassAnnotation(Class annotation)</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-invocation4"/>2.6. Metadata</h2>
                     </div>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="impl-metadata1"/>2.6.1. Resolving XML Metadata</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            Untyped metadata can be defined within XML files and bound to org.jboss.aop.metadata.SimpleMetaData structures.
            This XML data can be attached per method, field, class, and constructor.
            To resolve this type of metadata, the Invocation object provides a method to abstract out where the
            metadata comes from.
         </p>
                  <pre class="programlisting">Object getMetaData(Object group, Object attr)</pre>
                  <p>
            When this method is called, the invocation will look for metadata in this order:
         </p>
                  <div class="orderedlist">
                     <ol>
                        <li>
                           <p>
                   First it looks in the Invocation's metadata (
                  <code class="literal">SimpleMetaData getMetaData()</code>)
               </p>
                        </li>
                        <li>
                           <p>
                  Next it looks in
                  <code class="literal">org.jboss.aop.metadata.ThreadMetaData.instance()</code>.  ThreadMetaData
                  allows you to override metadata for the whole thread.  The metadata is managed by a ThreadLocal.
                  ThreadMetaData is used by every single invocation object at runtime.
               </p>
                        </li>
                        <li>
                           <p>
                  Next it looks in either org.jboss.aop.Advisor.getMethodMetaData(), Advisor.getConstructorMetaData(), or Advisor.getFieldMetaData()
                  depending on the invocation type.
               </p>
                        </li>
                        <li>
                           <p>
                  Next it looks in either Advisor.getDefaultMetaData().
               </p>
                        </li>
                     </ol>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="impl-metadata2"/>2.6.2. Attaching Metadata</h3>
                        </div>
                     </div>
                  </div>
                  <p>
         You can attach untyped metadata to the invocation object, or even to the response.  This allows advices
         to pass contextual data to one another in the incoming invocation or outgoing response for instance if you
         had advices running on a remote client that wanted to pass contextual data to server-side aspects.  This method
         on invocation gets you access to a
            <code class="literal">org.jboss.aop.metadata.SimpleMetaData</code> instance so that you can attach
         or read data.
         </p>
                  <pre class="programlisting">SimpleMetaData getMetaData()</pre>
                  <p>
            
                     <code class="literal">SimpleMetaData</code> has three types of metadata, AS_IS, MARSHALLED, and TRANSIENT.  This allows
         you to specify whether or not metadata is marshalled across the wire.  TRANSIENT says, attached metadata
         should not be sent across the wire.  MARSHALLED is for classloader sensitive contextual data.  AS_IS doesn't
         care about classloaders.  Read the Javadocs for more information.
         </p>
                  <p>
         To piggyback and read metadata on the invocation response, two methods are provided.  One to attach data
         one to read data.
         </p>
                  <pre class="programlisting">Object getResponseAttachment(Object key);
void addResponseAttachment(Object key, Object value);
         </pre>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-mixin"/>2.7. Mixin Definition</h2>
                     </div>
                  </div>
               </div>
               <p>
         Mixins are a type of introduction in which you can do something like C++ multiple inheritance and force
         an existing Java class to implement a particular interface and the implementation of that particular interface
         is encapsulated into a particular class called a mixin.
      </p>
               <p>
         Mixin classes have no restrictions other than they must implement the interfaces that you are introducing.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="impl-dyn-cflow"/>2.8. Dynamic CFlow</h2>
                     </div>
                  </div>
               </div>
               <p>
         Dynamic CFlows allow you to define code that will be executed that must be resolved true to trigger
         positive on a cflow test on an advice binding. (See &lt;cflow-stack&gt; for more information).
         The test happens dynamically at runtime and when combined with a pointcut expression allows you to
         do runtime checks on whether a advice binding should run or not.

         To implement a dynamic CFlow you just have to implement the simple org.jboss.aop.pointcut.DynamicCFlow
         interface.  You can then use it within cflow expressions.  (See XML or Annotations)
      </p>
               <pre class="programlisting">public interface DynamicCFlow
{
   boolean shouldExecute(Invocation invocation);
}</pre>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="pointcuts"/>Chapter 3. Joinpoint and Pointcut Expressions</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-wilcards">3.1. Wildcards</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-types">3.2. Type Patterns</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-method">3.3. Method Patterns</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-con">3.4. Constructor Patterns</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-field">3.5. Field Patterns</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-pointcut">3.6. Pointcuts</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-composition">3.7. Pointcut Composition</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-ref">3.8. Pointcut References</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-typedef">3.9. Typedef Expressions</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#pointcuts-joinpoints">3.10. Joinpoints</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#pointcuts-beans">3.10.1. Joinpoint Beans</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#pointcuts-contextvalues">3.10.2. Context Values</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
               </dl>
            </div>
            <p>
      The pointcut language is a tool that allows joinpoint matching. A pointcut expression determines in
      which joinpoint executions of the base system an advice should be invoked.
   </p>
            <p>
      In this Chapter, we will explore the syntax of pointcut expressions.
   </p>
            <p>
      We will also see the API used to represent a matched joinpoint during advice execution,
      and how this relates to pointcut expression constructs.
   </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-wilcards"/>3.1. Wildcards</h2>
                     </div>
                  </div>
               </div>
               <p>
         There are two types of wildcards you can use within pointcut expressions
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">*</code>  Is a regular wildcard that matches zero or more characters.
            It can be used within any type expression, field, or method name, but not in an annotation expression
            </li>
                     <li>
                        <code class="literal">..</code>  Is used to specify any number of parameters in an constructor or method
               expression. <code class="literal">..</code> following a package-name is used to specify all classes from within a given 
               package ut not within sub-packages. e.g <code class="literal">org.acme..</code> matches 
               <code class="literal">org.acme.Foo</code> and <code class="literal">org.acme.Bar</code>, but it does not match
               <code class="literal">org.acme.sub.SubFoo</code>.
            </li>
                  </ul>
               </div>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-types"/>3.2. Type Patterns</h2>
                     </div>
                  </div>
               </div>
               <p>
         Type patterns are defined by an annotation or by fully qualified class name.  Annotation expressions
         are not allowed to have wildcards within them, but class expressions are.
      </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">org.acme.SomeClass</code> matches that class.
         </li>
                     <li>
                        <code class="literal">org.acme.*</code> will match
            <code class="literal">org.acme.SomeClass</code> as well as
            <code class="literal">org.acme.SomeClass.SomeInnerClass</code>
                     </li>
                     <li>
                        <code class="literal">@javax.ejb.Entity</code> will match any class tagged as such.
         </li>
                     <li>
                        <code class="literal">String</code> or
            <code class="literal">Object</code> are illegal.  You must specify the fully
            qualified name of every java class.  Even those under the
            <code class="literal">java.lang</code> package.
         </li>
                  </ul>
               </div>
               <p>
          To reference all subtypes of a certain class (or implementors of an interface), the
         <code class="literal">$instanceof{}</code> expression can be used.  Wildcards and annotations may also be used 
         within <code class="literal">$instanceof{}</code> expressions.
      </p>
               <pre class="programlisting">
         $instanceof{org.acme.SomeInterface}
         $instanceof{@org.acme.SomeAnnotation}
         $instanceof{org.acme.interfaces.*}
      </pre>
               <p>are all allowed.</p>
               <p>
         For very complex type expressions, the Typedef construct can be used.  To reference a Typedef within a class
         expression
         <code class="literal">$typedef{id}</code> is used.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-method"/>3.3. Method Patterns</h2>
                     </div>
                  </div>
               </div>
               <pre class="programlisting">public void org.acme.SomeClass-&gt;methodName(java.lang.String)</pre>
               <p>
        The attributes(
         <code class="literal">public, static, private</code>) of the method are optional.  If the attribute
         is left out then any attribute is assumed.  Attributes accept the
         <code class="literal">!</code> modifier for negation.
      </p>
               <pre class="programlisting">public !static void org.acme.SomeClass-&gt;*(..)</pre>
               <p>
         
                  <code class="literal">$instanceof{}</code> can be used in place of the class name.
      </p>
               <pre class="programlisting">void $instanceof{org.acme.SomeInterface}-&gt;methodName(java.lang.String)</pre>
               <p>
         To pick out all <code class="literal">toString()</code> methods of all classes within the <code class="literal">org.acme</code>
         package, we can use <code class="literal">org.acme..</code> in place of the class name.
      </p>
               <pre class="programlisting">java.lang.String org.acme..-&gt;toString()</pre>
               <p>
         To only match methods from a given interface you can use the <code class="literal">$implements{}</code> or 
         <code class="literal">$implementing{}</code> keywords in place of the method name. <code class="literal">$implements{}</code>
         only matches methods from the exact interface(s) given, while <code class="literal">$implementing{}</code>
         matches methods from the interface(s) given AND their super interfaces.
      </p>
               <pre class="programlisting">void $instanceof{org.acme.IfA}-&gt;$implements(org.acme.IfA)(..)</pre>
               <pre class="programlisting">void $instanceof{org.acme.IfB}-&gt;$implementing(org.acme.IfA, org.acme.IfB)(..)</pre>
               <p>
         Annotations can be used in place of the class name.  The below example matches any methodName() of a tagged
         @javax.ejb.Entity class.
      </p>
               <pre class="programlisting">void @javax.ejb.Entity-&gt;methodName(java.lang.String)</pre>
               <p>
         Annotations can be also be used in place of the method name.  The below examples matches any method tagged as
         @javax.ejb.Tx.
      </p>
               <pre class="programlisting">* *-&gt;@javax.ejb.Tx(..)</pre>
               <p>
         In addition you can use typedefs, <code class="literal">$instanceof{}</code>, annotations and wildcards 
         for method parameters and return types. The following matches all methods called <code class="literal">loadEntity</code>
         that return a class annotated with @javax.ejb.Entity, that takes a class (or a class whose superclass/interface is)
         annotated as @org.acme.Ann and any class that matches <code class="literal">java.*.String</code> (such as java.lang.String).
      </p>
               <pre class="programlisting">@javax.ejb.Entity *-&gt;loadEntity($instanceof{@org.acme.Ann}, java.*.String)</pre>
      You can also include an optional throws clause in the pointcut expression:
      <pre class="programlisting">public void org.acme.SomeClass-&gt;methodName(java.lang.String) \
      throws org.acme.SomeException, java.lang.Exception</pre>
      If any exceptions are present in the pointcut expression they must be present in the throws clause of the
      methods to be matched. 
   </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-con"/>3.4. Constructor Patterns</h2>
                     </div>
                  </div>
               </div>
               <pre class="programlisting">public org.acme.SomeClass-&gt;new(java.lang.String)</pre>
               <p>
        Constructor expressions are made up of the fully qualified classname and the
         <code class="literal">new</code> keyword
        The attributes(
         <code class="literal">public, static, private</code>) of the method are optional.  If the attribute
         is left out then any attribute is assumed.  Attributes accept the
         <code class="literal">!</code> modifier for negation.
      </p>
               <pre class="programlisting">!public org.acme.SomeClass-&gt;new(..)</pre>
               <p>
         
                  <code class="literal">$instanceof{}</code> can be used in the class name.
      </p>
               <pre class="programlisting">$instanceof{org.acme.SomeInterface}-&gt;new(..)</pre>
               <p>
         To pick out all no-args constructors of all classes within the <code class="literal">org.acme</code>
         package, we can use <code class="literal">org.acme..</code> in place of the class name.
      </p>
               <pre class="programlisting">org.acme..-&gt;new()</pre>
               <p>
         Annotations can be used in place of the class name.  The below example matches any constructor of a tagged
         @javax.ejb.Entity class.
      </p>
               <pre class="programlisting">@javax.ejb.Entity-&gt;new(..)</pre>
               <p>
         Annotations can be also be used in place of the
         <code class="literal">new</code> keyword.  The below examples matches any constructor tagged as
         <code class="literal">@javax.ejb.MethodPermission.</code>
      
               </p>
               <pre class="programlisting">*-&gt;@javax.ejb.MethodPermission(..)</pre>
               <p>
         In addition, just as for methods you can use typedefs, <code class="literal">$instanceof{}</code>, 
         annotations and wildcards for constructor parameters. The following matches all constructors
         that take a class annotated as @org.acme.Ann and any class 
         that matches <code class="literal">java.*.String</code> (such as java.lang.String).
      </p>
               <pre class="programlisting">*-&gt;new(@org.acme.Ann, java.*.String)</pre>
               <p>You can also include an optional throws clause in the pointcut expression:</p>
               <pre class="programlisting">public void org.acme.SomeClass-&gt;new(java.lang.String) \
      throws org.acme.SomeException, java.lang.Exception</pre>
               <p>If any exceptions are present in the pointcut expression they must be present in the throws clause of the
      constructors to be matched.</p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-field"/>3.5. Field Patterns</h2>
                     </div>
                  </div>
               </div>
               <pre class="programlisting">public java.lang.String org.acme.SomeClass-&gt;fieldname</pre>
               <p>
        Constructor expressions are made up of the type, the fully qualified classname where the field resides and the
         field's name.
        The attributes(
         <code class="literal">public, static, private</code>) of the field are optional.  If the attribute
         is left out then any attribute is assumed.  Attributes accept the
         <code class="literal">!</code> modifier for negation.
      </p>
               <pre class="programlisting">!public java.lang.String org.acme.SomeClass-&gt;*</pre>
               <p>
         
                  <code class="literal">$instanceof{}</code> can be used in the class name.  The below expression matches any field
         of any type or subtype of
         <code class="literal">org.acme.SomeInterface</code>
      
               </p>
               <pre class="programlisting">* $instanceof{org.acme.SomeInterface}-&gt;*</pre>
               <p>
         Annotations can be used in place of the class name.  The below example matches any field where the type class 
         is tagged with
         <code class="literal">@javax.ejb.Entity</code>.
      </p>
               <pre class="programlisting">* @javax.ejb.Entity-&gt;*</pre>
               <p>
         Annotations can be also be used in place of the field name.  The below examples matches any field tagged as
         <code class="literal">@org.jboss.Injected.</code>
      
               </p>
               <pre class="programlisting">* *-&gt;@org.jboss.Injected</pre>
               <p>
         In addition, you can use typedefs, <code class="literal">$instanceof{}</code>, annotations and wildcards for field types. 
         The following matches all fields where the type class has been tagged with @javax.ejb.Entity.
      </p>
               <pre class="programlisting">@javax.ejb.Entity *-&gt;*</pre>
               <p>
         To pick out all fields annotated with <code class="literal">@org.foo.Transient</code> within the <code class="literal">org.acme</code>
         package, we can use <code class="literal">org.acme..</code> in place of the class name, and <code class="literal">@org.foo.Transient</code>
         in please of the field name
      </p>
               <pre class="programlisting">* org.acme..-&gt;@org.foo.Transient</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-pointcut"/>3.6. Pointcuts</h2>
                     </div>
                  </div>
               </div>
               <p>
         Pointcuts use class, field, constructor, and method expressions to specify the actual joinpoint that should
         be intercepted/watched.
      </p>
               <div class="variablelist">
                  <dl>
                     <dt>
                        <span class="term">
               
                           <code class="literal">execution(method or constructor)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">execution(public void Foo-&gt;method()
execution(public Foo-&gt;new())</pre>
                        <p>
                  
                           <code class="literal">execution</code> is used to specify that you want an interception to happen
                  whenever a method or constructor is called.  The the first example of matches anytime a method
                  is called, the second matches a constructor.  System classes cannot be used within
                  <code class="literal">execution</code>
                  expressions because it is impossible to instrument them.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">construction(constructor)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">construction(public Foo-&gt;new())</pre>
                        <p>
                  
                           <code class="literal">construction</code> is used to specify that you want aspects to run within the constructor.
                  The <code class="literal">execution</code> pointcut requires that any code that calls new() must be instrumented
                  by the compiler.  With <code class="literal">construction</code> the aspects are weaved right within the constructor
                  after all the code in the constructor.  The aspects are appended to the code of the constructor.  
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">get
               (field expression)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">get(public int Foo-&gt;fieldname)</pre>
                        <p>
                  
                           <code class="literal">get</code> is used to specify that you want an interception to happen
                  when a specific field is accessed for a read.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">set(field expression)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">get(public int Foo-&gt;fieldname)</pre>
                        <p>
                  
                           <code class="literal">set</code> is used to specify that you want an interception to happen
                  when a specific field is accessed for a write.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">field(field expression)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">field(public int Foo-&gt;fieldname)</pre>
                        <p>
                  
                           <code class="literal">field</code> is used to specify that you want an interception to happen
                  when a specific field is accessed for a read or a write.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">all(type expression)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">all(org.acme.SomeClass)
all(@org.jboss.security.Permission)</pre>
                        <p>
                  
                           <code class="literal">all</code> is used to specify any constructor, method or field of a particular class
                  will be intercepted.  If an annotation is used, it matches the member's annotation, not the class's
                  annotation.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">call(method or constructor)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">call(public void Foo-&gt;method()
call(public Foo-&gt;new())</pre>
                        <p>
                  
                           <code class="literal">call</code> is used to specify any constructor or method that you want intercepted.
                  It is different than
                  <code class="literal">execution</code> in that the interception happens at the caller side
                  of things and the caller information is available within the Invocation object.
                  <code class="literal">call</code>
                  can be used to intercept System classes because the bytecode weaving happens within the callers bytecode.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">within(type expression)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">within(org.acme.SomeClass)
within(@org.jboss.security.Permission)</pre>
                        <p>
                  
                           <code class="literal">within</code> matches any joinpoint (method or constructor call) within any code within a
                  particular type.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">withincode(method or constructor)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">withincode(public void Foo-&gt;method()
withincode(public Foo-&gt;new())</pre>
                        <p>
                  
                           <code class="literal">withincode</code> matches any joinpoint (method or constructor call) within a particular
                  method or constructor.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">has(method or constructor)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">has(void *-&gt;@org.jboss.security.Permission(..))
has(*-&gt;new(java.lang.String))</pre>
                        <p>
                  
                           <code class="literal">has</code> is an additional requirement for matching.  If a joinpoint is matched, its
                  class must also have a constructor or method that matches the
                  <code class="literal">has</code> expression.
               </p>
                     </dd>
                     <dt>
                        <span class="term">
               
                           <code class="literal">hasfield(field expression)</code>
            
                        </span>
                     </dt>
                     <dd>
                        <pre class="programlisting">hasfield(* *-&gt;@org.jboss.security.Permission)
hasfield(public java.lang.String *-&gt;*)</pre>
                        <p>
                  
                           <code class="literal">has</code> is an additional requirement for matching.  If a joinpoint is matched, its
                  class must also have a field that matches the
                  <code class="literal">hasfield</code> expression.
               </p>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-composition"/>3.7. Pointcut Composition</h2>
                     </div>
                  </div>
               </div>
               <p>
         Pointcuts can be composed into boolean expressions.
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">!</code>  logical not.
            </li>
                     <li>
                        <code class="literal">AND</code>  logical and.
            </li>
                     <li>
                        <code class="literal">OR</code>  logical or.
            </li>
                     <li>
               Paranthesis can be used for grouping expressions.
            </li>
                  </ul>
               </div>
               <p>
      
               </p>
               <p>
         Here's some examples.
      </p>
               <pre class="programlisting">call(void Foo-&gt;someMethod()) AND withincode(void Bar-&gt;caller())
execution(* *-&gt;@SomeAnnotation(..)) OR field(* *-&gt;@SomeAnnotation)</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-ref"/>3.8. Pointcut References</h2>
                     </div>
                  </div>
               </div>
               <p>
         Pointcuts can be named in XML (<a href="#xml" title="Chapter 5. XML Bindings">Chapter 5, <i xmlns:xlink="http://www.w3.org/1999/xlink">XML Bindings</i>
                  </a>) or annotation (<a href="#annotated" title="Chapter 6. Annotation Bindings">Chapter 6, <i xmlns:xlink="http://www.w3.org/1999/xlink">Annotation Bindings</i>
                  </a>) bindings.  They can be referenced directly
         within a pointcut expression.
      </p>
               <pre class="programlisting">some.named.pointcut OR call(void Foo-&gt;someMethod())</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-typedef"/>3.9. Typedef Expressions</h2>
                     </div>
                  </div>
               </div>
               <p>
         Sometimes, when writing pointcuts, you want to specify a really complex type they may or may not
         have boolean logic associated with it.  You can group these complex type definitions into a JBoss AOP
         <code class="literal">Typedef</code> either in XML or as an annotation (See later in this document).  Typedef expressions
         can also be used within
         <code class="literal">introduction</code> expressions.

         Typedef expressions can be made up of
         <code class="literal">has, hasfield, and class</code> expressions.
         <code class="literal">class</code>
         takes a fully qualified class name, or an
         <code class="literal">$instanceof{}</code> expression.
      </p>
               <pre class="programlisting">class(org.pkg.*) OR has(* *-&gt;@Tx(..)) AND !class($instanceof{org.foo.Bar})</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="pointcuts-joinpoints"/>3.10. Joinpoints</h2>
                     </div>
                  </div>
               </div>
               <p>
         After getting acquainted with all pointcut constructs, let's see how this reflects on the API
         available to advices during their execution.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="pointcuts-beans"/>3.10.1. Joinpoint Beans</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            JBoss AOP provides JoinPoint Beans, so that an advice can access all information regarding a joinpoint during
            its execution. This information consists of context values, explained in the next subsection, and of reflection
            objects (<code class="literal">java.lang.reflection</code>). The reflection objects describe the joinpoint being intercepted 
            like a <code class="literal">java.lang.Method</code> for a method execution joinpoint).
         </p>
                  <p>
            There are two groups of beans. The first one is the <code class="literal">Invocation</code> beans group. All classes of this group are
            subclasses of <code class="literal">org.jboss.aop.joinpoint.Invocation</code>. The <code class="literal">Invocation</code> class was presented in
            <a href="#implementing" title="Chapter 2. Implementing Aspects">Chapter 2</a> as a runtime encapsulation of a joinpoint. An <code class="literal">Invocation</code> object also contains
            an interceptor chain, where all advices and interceptors that intercept the joinpoint are stored. Invocation beans provide
            the <code class="literal">invokeNext()</code> method, responsible for proceeding execution to the next advice in the interceptor chain
            (if there is an advice that has not started execution yet) or to the joinpoint itself (if all advices contained in the interceptor
            chain have already started running). We will see more on this in the next chapter.
         </p>
                  <p>
            The other group of beans contains only information regarding the joinpoint itself, and are called the <code class="literal">
            JoinPointBean</code> group. All beans of this group are defined in interfaces, with <code class="literal">
            org.jboss.joinpoint.JoinPointBean</code> being their common superinterface.
         </p>
                  <p>
            The <code class="literal">Invocation</code> objects are available only to around advices. All other types of advices can use the
            <code class="literal">JoinPointBean</code> types to access joinpoint specific data.
         </p>
                  <p>
            In both groups there is a specific type for each joinpoint type. The type of bean corresponding to each joinpoint type can be seen
            in <a href="#pointcuts-typetable" title="Table 3.1.  Joinpoint Types Table">Table 3.1, “
              Joinpoint Types Table
            ”</a>. All beans are in the package <code class="literal">org.jboss.aop.joinpoint</code>.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="pointcuts-contextvalues"/>3.10.2. Context Values</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            According to the type of the joinpoint, there are specific context values available.
         </p>
                  <p>
            The context values are:
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
               return value: joinpoints like a constructor execution or a non-void method call, have a return value.
            </li>
                        <li>
            	arguments: the arguments of a constructor or method execution joinpoint are the arguments received
               by the constructor or method. Similarly, the arguments of a call are the arguments received by the
               method or constructor being called.
            </li>
                        <li>
               target: the target object of a joinpoint varies according to the joinpoint type. For method
               executions and calls, it refers to the object whose method is being executed (available only
               on non-static methods). For field reads and writes, it refers to the object that contains that
               field.
            </li>
                        <li>
               caller: the caller object is available only on call joinpoints, and it refers to the object
               whose method or constructor is performing the call (notice the caller object is not available if
               the call is inside a static method).
            </li>
                     </ul>
                  </div>
                  <p>
            
                     <a href="#pointcuts-typetable" title="Table 3.1.  Joinpoint Types Table">Table 3.1, “
              Joinpoint Types Table
            ”</a> shows what context values may be available depending on the joinpoint type.
         </p>
                  <div class="table">
                     <a id="pointcuts-typetable"/>
                     <div class="table-contents">
                        <table summary="&#xA;              Joinpoint Types Table&#xA;            " border="1">
                           <colgroup>
                              <col align="center"/>
                              <col align="center"/>
                              <col align="center"/>
                              <col align="center"/>
                              <col align="center"/>
                              <col align="center"/>
                              <col align="center"/>
                              <col align="center"/>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th rowspan="2" align="center">Joinpoint</th>
                                 <th rowspan="2" align="center">Pointcut Construct</th>
                                 <th colspan="2" align="center">Bean</th>
                                 <th colspan="4" align="center">ContextValues</th>
                              </tr>
                              <tr>
                                 <th align="center">Invocation</th>
                                 <th align="center">JoinpointBean</th>
                                 <th align="center">Target</th>
                                 <th align="center">Caller</th>
                                 <th align="center">Arguments</th>
                                 <th align="center">Return Value</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td align="center">field read</td>
                                 <td align="center">
                                    <code class="literal">read</code>, <code class="literal">field</code>, <code class="literal">all</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">FieldReadInvocation</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">FieldAccess</code>
                                 </td>
                                 <td align="center">Yes</td>
                                 <td align="center">No</td>
                                 <td align="center">No</td>
                                 <td align="center">Yes</td>
                              </tr>
                              <tr>
                                 <td align="center">field write</td>
                                 <td align="center">
                                    <code class="literal">write</code>, <code class="literal">field</code>, <code class="literal">all</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">FieldWriteInvocation</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">FieldAccess</code>
                                 </td>
                                 <td align="center">Yes</td>
                                 <td align="center">No</td>
                                 <td align="center">Yes</td>
                                 <td align="center">No</td>
                              </tr>
                              <tr>
                                 <td align="center">method execution</td>
                                 <td align="center">
                                    <code class="literal">execution</code>, <code class="literal">all</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">MethodInvocation</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">MethodExecution</code>
                                 </td>
                                 <td align="center">Yes</td>
                                 <td align="center">No</td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                              </tr>
                              <tr>
                                 <td align="center">constructor execution</td>
                                 <td align="center">
                                    <code class="literal">execution</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">ConstructorInvocation</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">ConstructorExecution</code>
                                 </td>
                                 <td align="center">No</td>
                                 <td align="center">No</td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                              </tr>
                              <tr>
                                 <td align="center">construction</td>
                                 <td align="center">
                                    <code class="literal">construction</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">ConstructionInvocation</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">ConstructorExecution</code>
                                 </td>
                                 <td align="center">Yes</td>
                                 <td align="center">No</td>
                                 <td align="center">Yes</td>
                                 <td align="center">No</td>
                              </tr>
                              <tr>
                                 <td align="center">method call</td>
                                 <td align="center">
                                    <code class="literal">call</code>, <code class="literal">within</code>, <code class="literal">withincode</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">CallerInvocation</code>, <code class="literal">MethodCalledByConstructorInvocation</code>, <code class="literal">MethodCalledByMethodInvocation</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">MethodCall</code>, <code class="literal">MethodCallByConstructor</code>, <code class="literal">MethodCallByMethod</code>
                                 </td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                              </tr>
                              <tr>
                                 <td align="center">constructor call</td>
                                 <td align="center">
                                    <code class="literal">call</code>, <code class="literal">within</code>, <code class="literal">withincode</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">CallerInvocation</code>, <code class="literal">ConstructorCalledByConstructorInvocation</code>, <code class="literal">ConstructorCalledByMethodInvocation</code>
                                 </td>
                                 <td align="center">
                                    <code class="literal">ConstructorCall</code>, <code class="literal">ConstructorCallByConstructor</code>, <code class="literal">ConstructorCallByMethod</code>
                                 </td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                                 <td align="center">Yes</td>
                              </tr>
                           </tbody>
                        </table>
            The first column shows the joinpoint type. The second column shows which pointcut constructs can identify a joinpoint of that type.
            <code class="literal">has</code> and <code class="literal">hasfield</code> are additional constructs, and therefore are not shown in this table. The
            third column shows the specific type of joinpoint bean class that is used to represent that joinpoint. This column is split into two:
            one for the <code class="literal">Invocation</code> beans, the other one for the <code class="literal">JoinPointBean</code> ones. The fourth column is
            composed of four subcolumns, and it shows the context values avaialble for each joinpoint type. Notice that, on some of these values,
            there are additional restrictions for their availability. Like, for example, there is no target on a static method execution.
         </div>
                     <p class="title">
                        <b>Table 3.1. 
              Joinpoint Types Table
            </b>
                     </p>
                  </div>
                  <br class="table-break"/>
               </div>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="advices"/>Chapter 4. Advices</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#adv-around">4.1. Around Advices</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#adv-batf">4.2. Before/After/After-Throwing/Finally Advices</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-beforesignature">4.2.1. Before Advice Signature</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-aftersignature">4.2.2. After Advice Signature</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-throwingsignature">4.2.3. After-Throwing Advice Signature</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-finallysignature">4.2.4. Finally Advice Signature</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#adv-annotatedparameters">4.3. Annotated Advice Parameters</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-thrown">4.3.1. @Thrown annotated parameter</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-joinpointargs">4.3.2. JoinPoint Arguments</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#adv-overloaded">4.4. Overloaded Advices</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-overlannotparam">4.4.1. Annotated-parameter Signature</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-overldefaultsignature">4.4.2. Default Signature</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#adv-overldiffsign">4.4.3. Mixing Different Signatures</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#adv-errors">4.5. Common Mistakes</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <p>
      Advices are aspect methods that are invoked during specific joinpoint executions.
   </p>
            <p>
      JBoss AOP provides five types of advice.
   </p>
            <p>
      The default one is the around advice, and it can be used on all execution modes.
      This advice wraps the joinpoint, in a way that it replaces the joinpoint execution in
      the base system, and is responsible for proceeding execution to the joinpoint.
   </p>
            <p>
      Besides around advices, you can write advices that, instead of wrapping the joinpoint,
      are executed before or after it. In this category, JBoss AOP provides before, after,
      after-throwing and finally advices. These advices are available only when using the generated
      advisor mode (this is the default mode in JBoss AOP, to learn how to select another weaving mode,
      refer to Chapter X).
   </p>
            <p>
      The next sections will explain in detail the binding and signature rules for JBoss AOP advices.
   </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="adv-around"/>4.1. Around Advices</h2>
                     </div>
                  </div>
               </div>
               <p>
         An around advice can follow this template:
      </p>
               <pre class="programlisting">
public Object [advice name]([Invocation] invocation) throws Throwable
{
   try{
      // do something before joinpoint execution
      ...
      // execute the joinpoint and get its return value
      Object returnValue = invocation.invokeNext();
      // do something after joinpoint has executed successfully ...
      // return a value
      return returnValue;
   }
   catch(Exception e)
   {
      //handle any exceptions arising from calling the joinpoint
      throw e;
   }
   finally
   {
      //Take some action once the joinpoint has completed successfully or not
   }
}</pre>
               <p>
         In the template above, <span class="emphasis">
                     <em>Invocation</em>
                  </span> refers to one of the <a href="#pointcuts-typetable" title="Table 3.1.  Joinpoint Types Table">Invocation beans</a>,
         and can be the class
         <code class="classname">org.jboss.aop.joinpoint.Invocation</code> or one of its subtypes.
      </p>
               <p>
         Since an around advice wraps a joinpoint, it must proceed execution to the joinpoint itself during its execution.
         This can be done by calling the method <code class="literal">invokeNext()</code> on <code class="literal">invocation</code>. This method will
         proceed execution to the next around advice of that joinpoint. At the end of this chain this <code class="literal">invokeNext()</code>
         will proceed to the joinpoint itself. The value returned by the around advice will replace the joinpoint return value in the base system.
      </p>
               <p>
         For example, in the case where there are two around advices bound to a joinpoint, the first around advice will
         trigger the second around advice by calling <code class="literal">invokeNext()</code>. The second advice will trigger
         the joinpoint execution by calling the same method. As a result of the <code class="literal">invokeNext()</code> execution,
         the second advice will receive the joinpoint return value. The value returned by this second advice will be received
         as a result by the first around advice. Finally, the value returned by this advice will replace the joinpoint
         return value in the base system execution. Normally though, around advices will simply return whatever value
         the joinpoint returned! This is shown in the preceding template example.
      </p>
               <p>
         If an around advice wants to completely replace the joinpoint execution, it can skip the call to <code class="literal">invokeNext()</code>.
         This will also skip execution of any subsequent around advices in the chain. As a third alternative, the around advice can
         call the method <code class="literal">invokeTarget()</code> instead of <code class="literal">invokeNext()</code>. This method will invoke 
         the target joinpoint directly, skipping any subsequent advices.
      </p>
               <p>
         The presence of the <code class="literal">Invocation</code> parameter is optional. If an around advice does not
         have this parameter, it can replace the call to <code class="literal">invokeNext()</code> with a call to
         <code class="literal">org.jboss.aop.joinpoint.CurrentInvocation.proceed()</code>.
      </p>
               <p>
         The signature described before is the default around advice signature rule. In addition to it,
         the around advice signature can also be of this form (only in generated advisor mode):
      </p>
               <pre class="programlisting">public [return type] [advice name]([annotated parameter],[annotated parameter],...[annotated parameter]) throws Throwable</pre>
               <p>
         This signature is joinpoint dependent. The return type of the advice must be a type assignable to the the return
         type of the joinpoint to be intercepted (i.e. be the same type; a subclass, if the return type is class; or a
         subinterface or an implementing class, if the return type is an interface). In case the joinpoint being intercepted
         does not have a return type, this advice return type must be <code class="literal">void</code>.
      </p>
               <p>
         An around advice can have zero or more annotated parameters. The annotated parameters will be covered in detail in
         <a href="#adv-annotatedparameters" title="4.3. Annotated Advice Parameters">Section 4.3, “Annotated Advice Parameters”</a>.
      </p>
               <p>
         Finally, JBoss AOP also features a special type of around advice: <code class="literal">Interceptor</code>. An interceptor class implements
         <code class="literal">org.jboss.aop.Interceptor</code>, and is described in <a href="#impl-interceptor" title="2.4. Interceptors">Section 2.4, “Interceptors”</a>.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="adv-batf"/>4.2. Before/After/After-Throwing/Finally Advices</h2>
                     </div>
                  </div>
               </div>
               <p>
         These advices are more lightweight in the JBoss AOP framework, since they do not wrap a joinpoint,
         avoiding the creation of the <code class="literal">Invocation</code> objects per joinpoint execution.
      </p>
               <p>
         Instead of <code class="literal">Invocation</code> objects, JBoss AOP provides <a href="#pointcuts-typetable" title="Table 3.1.  Joinpoint Types Table">JoinPointBean beans</a>
         for these advices. As described in <a href="#pointcuts-beans" title="3.10.1. Joinpoint Beans">Section 3.10.1, “Joinpoint Beans”</a>, these beans contain all information regarding a joinpoint,
         like an <code class="literal">Invocation</code> would do. However, since <code class="literal">JoinPointBean</code> objects are not used on around
         advice types, they do not provide proceeding methods, like <code class="literal">invokeNext()</code>. They also do not allow you to
         attach metadata for a particular invocation.
      </p>
               <p>
         The rules for before, after, after-throwing and finally advices are quite similar. All of them can have zero or more
         annotated advice parameters in their signature, which will be described in the next subsection.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-beforesignature"/>4.2.1. Before Advice Signature</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            A before advice is executed before the joinpoint. The signature for a before advice must be of this form:
         </p>
                  <pre class="programlisting">public void [advice name]([annotated parameter], [annotated parameter],...[annotated parameter])</pre>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-aftersignature"/>4.2.2. After Advice Signature</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            Since an after advice is executed after a joinpoint, it can return a value to replace the joinpoint return value
            in the base system. So, they can follow one of these signatures:
         </p>
                  <pre class="programlisting">public void [advice name]([annotated parameter], [annotated parameter],...[annotated parameter])

public [return type] [advice name]([annotated parameter], [annotated parameter],...[annotated parameter])</pre>
                  <p>
            In the first signature, the after advice does not overwrite the joinpoint return value.
            On the other hand, when using the second signature, the after advice return value will replace
            the joinpoint return value. As with around advices, this return type must be assignable to
            the joinpoint return type.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-throwingsignature"/>4.2.3. After-Throwing Advice Signature</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            The fourth type of advice provided by JBoss AOP is the after-throwing type. This advice is invoked only
            after the execution of a joinpoint that has thrown a <code class="literal">java.lang.Throwable</code> or one of its subtypes. 
         </p>
                  <p>
            The signature of such an advice is the same as the one for before advices:
         </p>
                  <pre class="programlisting">public void [advice name]([annotated parameter], [annotated parameter],...[annotated parameter])</pre>
                  <p>
            Different from the other advice types, an after-throwing advice has a mandatory annotated parameter. This parameter
            is the exception thrown by the joinpoint execution, as we will see in the next subsection.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-finallysignature"/>4.2.4. Finally Advice Signature</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            Lastly, JBoss AOP provides the finally advice type. It is invoked from inside a finally block, after the joinpoint execution.
         </p>
                  <p>
            This advice is the only one that is called after a joinpoint execution in a deterministic way. Calls to after and after-throwing
            advices take place depending on the joinpoint execution outcome. After advices are not called when the joinpoint execution
            terminates abruptly with an exception. After-throwing ones, on the other hand, are not called when the joinpoint execution
            returns normally, since no exception is thrown this time. So, if an advice needs to be run no matter what is the outcome
            of the joinpoint, it should be a finally advice.
         </p>
                  <p>
            Pretty much as after advices, finally advices can follow one of the signatures below:
         </p>
                  <pre class="programlisting">public void [advice name]([annotated parameter], [annotated parameter],...[annotated parameter])

public [return type] [advice name]([annotated parameter], [annotated parameter],...[annotated parameter])</pre>
                  <p>
            The last signature shows that finally advices can also overwrite the joinpoint execution return value by
            returning a value themselves. But notice that this return value will not be received by the base system if
            an exception has been thrown. However, it is easy to know whether this condition is met, by making use of annotated parameters.
         </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="adv-annotatedparameters"/>4.3. Annotated Advice Parameters</h2>
                     </div>
                  </div>
               </div>
               <p>
         This section lists the annotated parameters that can be used on JBoss AOP advices (available only in generated advisor
         execution mode). <a href="#adv-annotparamtable" title="Table 4.1. Annotated Parameters Table">Table 4.1, “Annotated Parameters Table”</a> lists all annotations and their semantics.
      </p>
               <p>
         Except for the <code class="literal">@JoinPoint</code> annotation, used to refer to joinpoint beans, all other annotations are used on
         parameters that contain joinpoint context values.
      </p>
               <p>
         Notice that the types of annotated parameters are dependent on the joinpoint being intercepted by the advice.
      </p>
               <p>
         JBoss AOP will accept any type that is assignable from the type referred by that parameter, as shown in the
         <span class="emphasis">
                     <em>Type Assignable From</em>
                  </span> column of the table below. For example, for a joinpoint whose target is of type
         <code class="literal">POJO</code>, the annotated parameter that receives the target must be of <code class="literal">POJO</code> type,
         one of <code class="literal">POJO</code>'s superclasses, or one of the interfaces implemented by <code class="literal">POJO</code>.
      </p>
               <p>
         Regarding the type of joinpoint bean parameters, the rules are the same for the default signature of around advices
         (without annotations). For example, an around advice that intercepts a method execution, can receive either a
         <code class="literal">MethodInvocation</code>, or an <code class="literal">Invocation</code> (the complete list of joinpoint beans
         and their relationship with joinpoint types was shown in <a href="#pointcuts-typetable" title="Table 3.1.  Joinpoint Types Table">Table 3.1, “
              Joinpoint Types Table
            ”</a>).
         As already explained, around advices use <code class="literal">Invocation</code> instances, while the other advices use
         <code class="literal">JoinPointBean</code> objects.
      </p>
               <p>
         Notice also that only one annotated parameter can be mandatory: <code class="literal">@Thrown</code>. This will be
         further explained in <a href="#adv-thrown" title="4.3.1. @Thrown annotated parameter">Section 4.3.1, “@Thrown annotated parameter”</a>.
      </p>
               <p>
         Except for <code class="literal">@Arg</code>, all annotations are single-enforced, i.e., there must be at most only
         one advice parameter with that annotation per advice.
      </p>
               <div class="table">
                  <a id="adv-annotparamtable"/>
                  <div class="table-contents">
                     <table summary="Annotated Parameters Table" border="1">
                        <colgroup>
                           <col align="center"/>
                           <col align="center"/>
                           <col align="center"/>
                           <col align="center"/>
                           <col align="center"/>
                           <col align="center"/>
                           <col align="center"/>
                           <col align="center"/>
                           <col align="center"/>
                        </colgroup>
                        <thead>
                           <tr>
                              <th rowspan="2" align="center">Annotation</th>
                              <th rowspan="2" align="center">Semantics</th>
                              <th rowspan="2" align="center">Type assignable from</th>
                              <th rowspan="2" align="center">Mandatory</th>
                              <th colspan="5" align="center">Advice type</th>
                           </tr>
                           <tr>
                              <th align="center">Before</th>
                              <th align="center">Around</th>
                              <th align="center">After</th>
                              <th align="center">After-Throwing</th>
                              <th align="center">Finally</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="2" align="center">
                                 <code class="literal">@JoinPoint</code>
                              </td>
                              <td rowspan="2" align="center">
                                 <a href="#pointcuts-beans" title="3.10.1. Joinpoint Beans">JoinPoint bean</a>
                              </td>
                              <td align="center">Joinpoint invocation type</td>
                              <td align="center">No</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">No</td>
                              <td align="center">No</td>
                              <td align="center">No</td>
                           </tr>
                           <tr>
                              <td align="center">JoinpointBean interface type</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                           </tr>
                           <tr>
                              <td align="center">
                                 <code class="literal">@Target</code>
                              </td>
                              <td align="center">Joinpoint target</td>
                              <td align="center">Joinpoint target type</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                           </tr>
                           <tr>
                              <td align="center">
                                 <code class="literal">@Caller</code>
                              </td>
                              <td align="center">Joinpoint caller</td>
                              <td align="center">JoinPoint caller type (only for call joinpoints)</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                           </tr>
                           <tr>
                              <td align="center">
                                 <code class="literal">@Thrown</code>
                              </td>
                              <td align="center">Joinpoint thrown exception</td>
                              <td align="left">
                                 <code class="literal">java.lang.Throwable</code>
                         
                                 <p>If used on an after-throwing advice, this parameter can also be:</p>
                         
                                 <p>- assignable from any exception declared to be thrown by the joinpoint</p>
                         
                                 <p>- <code class="literal">java.lang.RuntimeException</code> or any subtype of this class</p>
                  
                              </td>
                              <td align="left">Yes:
                     <p>- for after-throwing advices</p>
                     
                                 <p>- for finally advices only if <code class="literal">@Return</code> is present</p>
                     
                                 <p>No: otherwise</p>
                  
                              </td>
                              <td align="center">No</td>
                              <td align="center">No</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                           </tr>
                           <tr>
                              <td align="center">
                                 <code class="literal">@Return</code>
                              </td>
                              <td align="center">Joinpoint return value</td>
                              <td align="center">JoinPoint return type</td>
                              <td align="center">No</td>
                              <td align="center">No</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                           </tr>
                           <tr>
                              <td align="center">
                                 <code class="literal">@Arg</code>
                              </td>
                              <td align="center">One of the joinpoint arguments</td>
                              <td align="center">JoinPoint argument type</td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                           </tr>
                           <tr>
                              <td align="center">
                                 <code class="literal">@Args</code>
                              </td>
                              <td align="center">All joinpoint arguments</td>
                              <td align="center">
                                 <code class="literal">java.lang.Object[]</code>
                              </td>
                              <td align="center">No</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                              <td align="center">Yes</td>
                           </tr>
                        </tbody>
                     </table>
         The first column shows the annotation to be used for each parameter type. All annotations are
         from the <code class="literal">org.jboss.aop.advice.annotation</code> package. The column <span class="emphasis">
                        <em>Semantics</em>
                     </span>
         shows what value each annotated parameter represents. The third column shows from which type the parameter
         type must be assignable (notice that <code class="literal">Throwable</code> and <code class="literal">Object[]</code> belong to
         <code class="literal">java.lang</code> package). The Mandatory column indicates whether that value must be present in
         order for the advice to be considered valid. Finally, the Advice Type column shows for which advice types that
         parameter is allowed.
      </div>
                  <p class="title">
                     <b>Table 4.1. Annotated Parameters Table</b>
                  </p>
               </div>
               <br class="table-break"/>
               <p>
         Due to the fact that most of these parameters represent context values, their availability depends on the joinpoint
         type. If an advice receives as a parameter a context value that is not available during a joinpoint execution, the
         parameter value will be null. The exception to this rule is @Return. If an advice has this parameter, it will not
         intercept joinpoints that don’t have a return value.
      </p>
               <p>
         The only exception to this rule is <code class="literal">@Args</code> on field read joinpoints. Such an advice will be called
         with an empty arguments array, in that case.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-thrown"/>4.3.1. @Thrown annotated parameter</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            As shown in <a href="#adv-annotparamtable" title="Table 4.1. Annotated Parameters Table">Table 4.1, “Annotated Parameters Table”</a>, the presence of a <code class="literal">@Thrown</code> annotated parameter
            can be mandatory depending on the advice type and its parameters.
         </p>
                  <p>
            This annotation is available only for after-throwing and finally advices. For after-throwing advices this parameter
            is always mandatory:
         </p>
                  <pre class="programlisting">public class Aspect
{
   public void throwing1(@Thrown RuntimeException thrownException)
   {
      ...
   }

   public void throwing2()
   {
      ...
   }
}


&lt;aop&gt;
   &lt;aspect class="Aspect"/&gt;
   &lt;bind pointcut="..."&gt;
      &lt;throwing aspect="Aspect" name="throwing1"/&gt;
      &lt;throwing aspect="Aspect" name="throwing2"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;</pre>
                  <p>
            The advice <code class="literal">throwing1</code> follows this rule; advice <code class="literal">throwing2</code>,
            on the other hand, is invalid, because it does not contain the mandatory <code class="literal">@Thrown</code>
            annotated parameter.
         </p>
                  <p>
            For finally advices, the <code class="literal">@Thrown</code> annotation is compulsory only if a
            <code class="literal">@Return</code> annotated parameter is present. This way, a finally advice can identify
            whether the return value is valid or not. If the <code class="literal">@Thrown</code> parameter is
            <code class="literal">null</code>, it means that the joinpoint returned normally and that the value contained in
            the <code class="literal">@Return</code> annotated-parameter is valid. Otherwise, the value contained in
            <code class="literal">@Return</code> annotated parameter must be ignored (it will be <code class="literal">null</code> if
            the return type is not primitive, <code class="literal">0</code> if it is a primitive number or <code class="literal">false</code>
            if it is boolean). If the finally advice does not receive the joinpoint return value, the use of the
            <code class="literal">@Thrown</code> annotated parameter is optional and, as expected, its value will be
            <code class="literal">null</code> if the joinpoint being intercepted did not throw an exception. Take a look at the
            next example:
         </p>
                  <pre class="programlisting">public class Aspect
{
   public void finally1(@Thrown Throwable thrownException)
   {
      ...
   }

   public void finally2()
   {
      ...
   }

   public void finally3(@Return int returnedValue, @Thrown Throwable thrownException)
   {
      if (thrownException == null)

      {

         //We returned normally, the @Return parameter is valid

         int i = returnedValue;

      }

      else

      {

         //An exception happened while invoking the target joinpoint

         //The return value is invalid

      }

    }

   public void finally4(@Return int returnedValue)
   {
      ...
   }

}


&lt;aop&gt;
   &lt;aspect class="Aspect"/&gt;
   &lt;bind pointcut="execution(public int *-&gt;*(..))"&gt;
      &lt;finally aspect="Aspect" name="finally1"/&gt;
      &lt;finally aspect="Aspect" name="finally2"/&gt;

      &lt;finally aspect="Aspect" name="finally3"/&gt;

      &lt;finally aspect="Aspect" name="finally4"/&gt;

   &lt;/bind&gt;
&lt;/aop&gt;</pre>
                  <p>
            This example binds four finally advices to the execution of all public methods that return an int value. Take note on the
            type of the <code class="literal">@Thrown</code>-annotated parameters, which must be <code class="literal">Throwable</code> for this type of
            advice.
         </p>
                  <p>
            The presence of <code class="literal">@Thrown</code> is not mandatory in advices <code class="literal">finally1()</code>
            and <code class="literal">finally2()</code>, because they do not have a <code class="literal">@Return</code> annotated parameter.
            Hence, both advices are valid. Besides, <code class="literal">finally1()</code> will receive a non-null exception only
            when the joinpoint being intercepted throws an exception.
         </p>
                  <p>
            For advice method <code class="literal">finally3()</code> the presence of a <code class="literal">@Thrown</code> annotated parameter
            is mandatory because this advice also has a <code class="literal">@Return</code> annotated parameter. If an exception
            happens when invoking the target joinpoint, this advice will receive a non-null <code class="literal">@Thrown</code> parameter,
            meaning that the <code class="literal">@Return</code> annotated parameter is invalid. If the joinpoint completes normally,
            the <code class="literal">@Thrown</code> annotated parameter will be <code class="literal">null</code> and the <code class="literal">@Return</code>
            annotated parameter will contain the return value of the target joinpoint.
         </p>
                  <p>
            The <code class="literal">finally4()</code> advice is invalid, it contains a <code class="literal">@Return</code> parameter, but has no
            <code class="literal">@Thrown</code> annotated parameter. Finally advices require a <code class="literal">@Thrown</code> parameter if a
            <code class="literal">@Return</code> annotated parameter is present.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-joinpointargs"/>4.3.2. JoinPoint Arguments</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            As we saw, an advice can receive the joinpoint arguments as annotated parameters. This can be achieved with the use of
            two different annotations: <code class="literal">@Arg</code> and <code class="literal">@Args</code>.
         </p>
                  <p>
            There is a great difference between these two approaches, though. With <code class="literal">@Arg</code>, each parameter is equivalent
            to a single joinpoint parameter. With <code class="literal">@Args</code>, one single parameter, of type <code class="literal">Object[]</code>,
            receives an array containing all joinpoint arguments. This last possibility is more generic than the first one, since it can be
            used independently of the joinpoint argument types. Plus, it allows changes to the argument values. Any changes performed on
            the values of this array will be perpetuated to the joinpoint execution. However, the use of <code class="literal">@Args</code> parameters
            on a join point interception means the arguments array needs creation. The same happens with the use of
            <code class="literal">getArguments()</code> and <code class="literal">setArguments()</code> methods on <code class="literal">Invocation</code> classes. So the
            use of <code class="literal">@Arg</code> annotated parameters is more lightweight, and should be used whenever there is no need to changing
            the joinpoint arguments.
         </p>
                  <p>
            When using <code class="literal">@Arg</code> annotated parameters, the types of these parameters depend on the joinpoint being intercepted.
            Not all the target joinpoint arguments need to be included as parameters to the advice method. An advice can receive only the
            argument values that are relevant to its execution.
         </p>
                  <p>
            Given all the possibilities in the usage of <code class="literal">@Arg</code>, JBoss AOP will match the advice parameters with the
            joinpoint ones, to infer to which joinpoint argument each advice parameter refers to. This matching process consists of
            the following steps:
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
                           <p>
               Each advice parameter will be matched to the first unmatched joinpoint argument that has the same type. This is done
               in the order that the advice parameters appear in the advice method.
            </p>
                        </li>
                        <li>
                           <p>
               If any advice parameter is left unmatched, we proceed to an additional step. Each advice parameter will be matched to
               the first unmatched joinpoint argument that is assignable to it. This is done in the order that the advice parameters
               appear in the advice method declaration.
            </p>
                        </li>
                     </ul>
                  </div>
                  <p>
            To illustrate this mechanism, consider the following scenario:
         </p>
                  <pre class="programlisting">public class POJO
{
    void method(Collection arg0,  List arg1, int arg2, String arg3){}
}


&lt;aop&gt;
   &lt;aspect class="MyAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;method(..))"&gt;
      &lt;before aspect="MyAspect" name="advice"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;</pre>
                  <p>
            The example above shows a xml-declared binding. We will use examples with those to illustrate
            signature concepts from now on. Detailed syntax of xml bindings is shown in <a href="#xml" title="Chapter 5. XML Bindings">Chapter 5, <i xmlns:xlink="http://www.w3.org/1999/xlink">XML Bindings</i>
                     </a>.
         </p>
                  <p>
            Class <code class="literal">POJO</code> is a plain java old object that contains only one method.
            When calling this method, we want to trigger <code class="literal">MyAspet.advice()</code> before this
            method is called. <code class="literal">POJO.method()</code> receives four distinct arguments, all of them
            can be available to an advice by using <code class="literal">@Arg</code> annotated parameters. If
            <code class="literal">MyAspect.advice()</code> has the following signature:
         </p>
                  <pre class="programlisting">public class MyAspect
{
   public void advice(@Arg Collection param0, @Arg List param1, @Arg int param2, @Arg String param3)
   {
      ...
   }
}</pre>
                  <p>
            
                     <code class="literal">MyAspect.advice()</code> parameters will be trivially matched to <code class="literal">POJO.method()</code> arguments
            as follows:
         </p>
                  <pre class="programlisting">
param0 &lt;- arg0
param1 &lt;- arg1
param2 &lt;- arg2
param3 &lt;- arg3
         </pre>
                  <p>
            The matching outcome will be the same if <code class="literal">MyAspect.advice()</code> signature changes slightly in the following
            manner, since <code class="literal">Collection</code> is assignable from <code class="literal">List</code> for <code class="literal">param2</code>:
         </p>
                  <pre class="programlisting">public class MyAspect
{
   public void advice (@Arg Collection param0, @Arg Collection param1, @Arg int param2, @Arg String param3)
   {
      ...
   }
}</pre>
                  <p>
            If <code class="literal">MyAspect.advice()</code> receives only one parameter, of type <code class="literal">java.lang.Object</code>:
         </p>
                  <pre class="programlisting">public class MyAspect
{
   public void advice(@Arg Object param0)
   {
      ...
   }
}</pre>
                  <p>
            The parameter matching outcome will be:
         </p>
                  <pre class="programlisting">
param0 &lt;- arg0
         </pre>
                  <p>
            Since there is no joinpoint argument of type <code class="literal">Object</code>, we proceed to the additional
            matching step in this case. Because <code class="literal">arg0</code> is the first unmatched argument that is assignable
            to <code class="literal">Object</code>, we assign this argument to <code class="literal">param0</code>.
         </p>
                  <p>
            Notice that JBoss AOP will match all parameters correctly if we invert the order of parameters:
         </p>
                  <pre class="programlisting">public class MyAspect
{
   public void advice(@Arg int param2, @Arg Collection param0, @Arg String param3, @Arg List param1)
   {
      ...
   }
}</pre>
                  <p>
            If one writes an advice whose unique parameter is a <code class="literal">Collection</code>, and we want to refer
            to the second joinpoint argument:
         </p>
                  <pre class="programlisting">public class MyAspect
{
   public void advice (@Arg Collection param1)
   {
      ...
   }
}</pre>
                  <p>
            It will not work as desired. JBoss AOP will assign <code class="literal">arg0</code> to <code class="literal">param1</code>:
         </p>
                  <pre class="programlisting">
param1 &lt;- arg0
         </pre>
                  <p>
            In cases like this, it is possible to enforce the correct matching of joinpoint arguments and
            advice parameters. The annotation <code class="literal">@Arg</code> has an attribute, index, whose purpose
            is to define the index of the argument to which that parameter refers.
         </p>
                  <p>
            So, in this case, the <code class="literal">MyAspect.advice()</code> parameter list below:
         </p>
                  <pre class="programlisting">public class MyAspect
{
   public void advice (@Arg(index=1) Collection param1)
   {
      ...
   }
}</pre>
                  <p>
            Will have the desired matching, which is:
         </p>
                  <pre class="programlisting">
param1 &lt;- arg1
         </pre>
                  <p>
            In the example just shown in this section, <code class="literal">MyAspect.advice()</code> was a before advice,
            but the same rules are used for all advices using <code class="literal">@Arg</code> annotated parameters.
         </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="adv-overloaded"/>4.4. Overloaded Advices</h2>
                     </div>
                  </div>
               </div>
               <p>
         Method names can be overloaded for interception in different joinpoint scenarios. For instance, let's
         say you wanted to have a different trace advice for each invocation type. You can specify the same method
         name <code class="literal">trace</code> and just overload it with the concrete invocation type.
      </p>
               <pre class="programlisting">public class AroundAspect
{
   public Object trace(MethodInvocation invocation) throws Throwabl
   {
      try
      {
         System.out.println("Entering method: " + invocation.getMethod()");
         return invocation.invokeNext(); // proceed to next advice or actual call
      }
      finally
      {
         System.out.println("Leaving method: " + invocation.getMethod()");
      }
   }
   
   public Object trace(ConstructorInvocation invocation) throws Throwable
   {
      try
      {
         System.out.println("Entering constructor: " + invocation.getConstructor()");
         return invocation.invokeNext(); // proceed to next advice or actual call
      }
      finally
      {
         System.out.println("Leaving constructor: " + invocation.getConstructor()");
      }
   }
}</pre>
               <p>
         As you can see, the selection of the advice method is very dynamic. JBoss AOP will select
         the most appropriate advice method for each joinpoint interception. For the following setup:
      </p>
               <pre class="programlisting">class POJO
{
   public POJO(){}
   public someMethod(){}
}

&lt;aop&gt;
   &lt;aspect class="AroundAspect"/&gt;
   &lt;bind pointcut="all(POJO)"&gt;
      &lt;advice aspect="AroundAspect" name="trace"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;</pre>
               <p>
         When calling POJO’s constructor:
      </p>
               <pre class="programlisting">pojo.someMethod();</pre>
               <p>
         JBoss AOP will call the <code class="literal">trace()</code> method taking a
         <code class="literal">ConstructorInvocation</code>, and when calling:
      </p>
               <pre class="programlisting">pojo.someMethod();</pre>
               <p>
         JBoss AOP will call the <code class="literal">trace()</code> method taking a <code class="literal">MethodInvocation</code>.
      </p>
               <p>
         This examples shows that JBoss AOP will select the most appropriate advice method for each
         joinpoint interception. The capability of selecting overloaded advices is available for all
         types of advices. And its impact in the system performance is minimal since this selection
         is done once.
      </p>
               <p>
         In this section, we will describe every rule JBoss AOP uses to select an advice method when this one
         is overloaded.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-overlannotparam"/>4.4.1. Annotated-parameter Signature</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            Let's start with the selection of advices when all of them use the annotated-parameter signature.
            As we will see later, very similar rules are used for selecting advices with the default signature.
         </p>
                  <p>
            The process of selection of advices that follow the annotated-parameter signature depends on the
            priority of each kind of parameter:
         </p>
                  <a id="annotparampriority"/>
                  <div class="informalequation">
                     <a id="equation"/>
                     <code class="literal">@JoinPoint</code> &gt; <code class="literal">@Target</code> &gt;
            <code class="literal">@Caller</code> &gt; <code class="literal">@Throwable</code> = <code class="literal">@Return</code> &gt;
            <code class="literal">@Arg</code> &gt; <code class="literal">@Args</code>
                  </div>
                  <p>
            This priority is used in two different criteria:
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
                           <p>
               presence of the annotated parameter
            </p>
                        </li>
                        <li>
                           <p>
               assignability degree of the annotation parameter
            </p>
                        </li>
                     </ul>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="adv-overlannotparampresence"/>4.4.1.1. Presence priority</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               This rule is quite simple, it means that an advice that receives only a joinpoint bean
               <code class="literal">(@JoinPoint)</code> as its parameter will have a higher priority than another advice
               that receives all other annotated parameters available (notice we are following the
               <a href="#annotparampriority">annotation priority order</a> just described).
            </p>
                     <p>
               In other words, the first <code class="literal">OneAspect.after()</code> advice method will be chosen when
               calling <code class="literal">POJO.someMethod()</code> in this example:
            </p>
                     <pre class="programlisting">public class POJO
{
   String someMethod(String s){}
}

&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;someMethod(..))"&gt;
      &lt;after aspect="OneAspect" name="after"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public void after(@JoinPoint MethodJoinPoint mjp){} //1
   public String after(@Target POJO pojo, @Return String ret, @Arg String arg0){} //2
}</pre>
                     <p>
               Again in the following example, the first <code class="literal">OneAspect.after()</code> advice method
               will be chosen when calling <code class="literal">POJO.someMethod()</code>. The first <code class="literal">after()</code>
               advice method’s highest priority parameter is <code class="literal">@Target</code>, the second advice parameter’s
               highest priority parameter is <code class="literal">@Return</code>, and <code class="literal">@Target</code> has a higher
               priority than <code class="literal">@Return</code>:
            </p>
                     <pre class="programlisting">public class POJO
{
   String someMethod(String s){}
}

&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;someMethod(..))"&gt;
      &lt;after aspect="OneAspect" name="after"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public void after(@Target POJO pojo){} //1
   public String after(@Return String ret, @Arg String arg0){} //2
}</pre>
                     <p>
               In cases where the highest priority annotated parameter of two advice methods is
               the same, we move on to the next highest priority annotated parameter of both advices.
               In the following scenario, both <code class="literal">OneAspect.after()</code> methods have the
               <code class="literal">@JoinPoint</code> parameter as the highest priority parameter. The first one
               has a <code class="literal">@Target</code> as its second-highest priority parameter while the second
               one has <code class="literal">@Return</code> as its second-highest priority parameter. Since
               <code class="literal">@Target</code> has a higher priority than <code class="literal">@Return</code>, the first
               <code class="literal">OneAspect.after()</code> is chosen for <code class="literal">POJO.someMethod()</code>.
            </p>
                     <pre class="programlisting">public class POJO
{
   String someMethod(String s){}
}

&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;someMethod(..))"&gt;
      &lt;after aspect="OneAspect" name="after"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public void after(@JoinPoint MethodJoinPoint mjp, @Target POJO pojo){} //1
   public String after(@JoinPoint MethodJoinPoint mjp, @Return String ret){} //2
}</pre>
                     <p>
               In the next example, the first <code class="literal">OneAspect.before()</code> advice is chosen
               over the second one when calling <code class="literal">POJO.someMethod()</code>. The reason is that,
               all else being equal, the first one matches more parameters:.
            </p>
                     <pre class="programlisting">public class POJO
{
   String someMethod(String s, int i){}
}

&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;someMethod(..))"&gt;
      &lt;before aspect="OneAspect" name="before"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public void before(@Arg String s, @Arg int i){} //1
   public String before(@Arg String s){} //2
}</pre>
                     <p>
               If the priority of annotated parameters using the presence criterion is the same
               on more than one advice, the next criterion, the assignability degree, is used.
            </p>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="adv-overlannotparamdegree"/>4.4.1.2. Assignability Degree</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               The assignability degree rule will select the advice with the lowest assignability
               degree on the highest priority parameter. The assignability degree is simply the distance
               in the class hierarchy between the parameter type, and the type it must be assignable from.
            </p>
                     <p>
               As an example, let us look at the following class hierarchy:
            </p>
                     <pre class="programlisting">public interface POJOInterface{}

public class POJOSuperClass extends java.lang.Object{}

public class POJO extends POJOSuperClass implements POJOInterface
{
   void method(){}
}</pre>
                     <p>
               And this advice binding:
            </p>
                     <pre class="programlisting">&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;method(..))"&gt;
      &lt;before aspect="OneAspect" name="before"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;

public class OneAspect
{
   public void before(@Target POJO target){} //1
   public void before(@Target POJOInterface target){} //2
   public void before(@Target POJOSuperClass target){} //3
   public void before(@Target Object target){} //4
}</pre>
                     <p>
               With <code class="literal">POJO</code> as the target of a joinpoint, the parameter list fo
               the first <code class="literal">OneAspect.before()</code> advice method has an assignability degree
               0 on <code class="literal">@Target</code>.
            </p>
                     <p>
               The parameter lists for the second and third <code class="literal">OneAspect.before()</code> advice
               methods both have an assignability degree of 1 for <code class="literal">@Target</code>, since it takes
               one step through the hierarchy to reach the desired type, <code class="literal">POJO</code>.
            </p>
                     <p>
               Finally, the parameter list for the fourth <code class="literal">OneAspect.before()</code> advice method
               has an assignability degree of 2 on <code class="literal">@Target</code>.
            </p>
                     <p>
               Hence, JBoss AOP will select the first advice in the example above, since it has the lowest
               asignability degree on <code class="literal">@Target</code>.
            </p>
                     <p>
               The assignability degree rule is, similarly to the presence rule, applied on the highest priority
               annotated parameter, which is <code class="literal">@JoinPoint</code>. In case there is a match using this
               criteria (i.e., either both advices lack a <code class="literal">@JoinPoint</code> annotated parameter, or
               they both have the same type on the <code class="literal">@JoinPoint</code> parameter), we move to the next
               highest priority annotated parameter, which is <code class="literal">@Target</code>. The same rule is applied
               until we can find an advice with the highest priority.
            </p>
                     <p>
               Notice that the assignability degree of an advice on <code class="literal">@Arg</code> is the sum of the
               assignability degree on all <code class="literal">@Arg</code> parameters. In the following scenario:
            </p>
                     <pre class="programlisting">public class POJO
{
   public void method(POJO argument0, String argument1, int argument2)
}


&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;method(..))"&gt;
      &lt;before aspect="OneAspect" name="before"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public void before(@Arg POJO p, @Arg String s, @Arg int i){} //1
   public void before(@Arg POJOSuperClass p, @Arg String s, @Arg int i){} //2
   public void before(@Arg POJO p, @Arg Object s, @Arg int i){} //3
   public void before(@Arg Object p, @Arg Object s, @Arg int i){} //4
}</pre>
                     <p>
               The first advice has assignability degree of 0 (for <code class="literal">POJO</code>) + 0
               (for <code class="literal">String</code>) + 0 (for <code class="literal">int</code>). Notice how primitive
               types don’t have superclasses, and, hence, have always a 0 value of assinability degree.
            </p>
                     <p>
               The second advice has a larger assignability degree, since <code class="literal">POJOSuperClass</code> is
               the superclass of <code class="literal">POJO</code>, <code class="literal">@Arg POJOSuperClass p</code> has
               assignability degree of 1. Hence, this advice assignability degree on <code class="literal">@Arg</code> is:
               1 + 0 + 0 = 1.
            </p>
                     <p>
               The third one also has an assignability degree of 1, since <code class="literal">Object</code> is the superclass
               of <code class="literal">String</code>.
            </p>
                     <p>
               Finally, the last advice has assignability degree of 3 on <code class="literal">@Arg</code>. The first parameter,
               <code class="literal">@Arg Object p</code>, refers to <code class="literal">POJO</code> and has assignability degree of 2.
               The second one, assignability degree of 1, since it refers to <code class="literal">String</code>. And, since
               <code class="literal">@Arg int</code> refers to the <code class="literal">int</code> argument of <code class="literal">POJO.method()</code>,
               we have 2 + 1 + 0 = 3.
            </p>
                     <p>
               In the above example, JBoss AOP would select the first advice to intercept <code class="literal">POJO.method()</code> execution.
            </p>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="adv-overlannotparamreturn"/>4.4.1.3. Return Types</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               For annotated parameters typed around advices, there is a third rule, which is the return type. This rule
               also applies to after and finally advices. If the joinpoint has a non-void return type, the assignability
               degree of the advice return type is analyzed, pretty much in the same way we do with annotated parameters.
               So, for overloaded around advices, these three criteria are applied:
            </p>
                     <div class="itemizedlist">
                        <ul>
                           <li>
                              <p>presence of annotated parameter</p>
                           </li>
                           <li>
                              <p>assignability degree of annotated parameter</p>
                           </li>
                           <li>
                              <p>assignability degree of return type</p>
                           </li>
                        </ul>
                     </div>
                     <p>
               If two advices have the same ranking on the first two criteria, we check their return types
               and pick the advice with the lowest assignability degree:
            </p>
                     <pre class="programlisting">public class POJO
{
   public Collection method(int arg0, boolean arg1, short arg2) {…}
}


&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;method(..))"&gt;
      &lt;advice aspect="OneAspect" name="around"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public Collection around(@JoinPoint Invocation inv, @Arg int param0) throws Throwable
   {...} //1

   public List around(@JoinPoint Invocation inv, @Arg boolean param1) throws Throwable
   {...} //2

}</pre>
                     <p>
               In OneAspect above, we have two around advices. Both of them are equal when compared
               using the presence criteria. When comparing them using the assignability of annotated
               parameter, both of them have the same degrees on <code class="literal">@JoinPoint</code> and on
               <code class="literal">@Arg</code> parameters. In this case, we will compare their return type
               assignability degree.
            </p>
                     <p>
               Notice that, when it comes to return types, it is the return type that must be assignable
               to the joinpoint type, and not the contrary. This is due to the fact that JBoss AOP will
               assign the advice return value to the joinpoint return result in the base system. Hence,
               in the example above, the caller of <code class="literal">POJO.method()</code> expects a
               <code class="literal">Collection</code> return value. So, it is ok to receive either a
               <code class="literal">Collection</code> from the first advice, as the more specific type
               <code class="literal">List</code> from the second advice. But JBoss AOP will complain if your advice
               returns an <code class="literal">Object</code> (<code class="literal">Object</code> return type is allowed only
               in the default signature; here we are discussing the annotated-parameter signature), because
               we can’t give an <code class="literal">Object</code> to the base system when it is expecting a
               <code class="literal">Collection</code>.
            </p>
                     <p>
               So, in the above example, the first advice has an assignability degree of 0 on the return type,
               becase it takes 0 steps in the hierarchy to go from Collection to <code class="literal">Collection</code>.
               In the second advice, this value is 1, because it takes 1 step to go from <code class="literal">List</code>
               to <code class="literal">Collection</code>. JBoss AOP would select the first advice.
            </p>
                     <p>
               On overloaded after and finally advices, we also have a return type rule. But, since the return type
               is optional (these advices can return a value, but is not enforced to it), we have a total of four rules
               for this advice:
            </p>
                     <div class="itemizedlist">
                        <ul>
                           <li>
                              <p>presence of annotated parameter</p>
                           </li>
                           <li>
                              <p>assignability degree of annotated parameter</p>
                           </li>
                           <li>
                              <p>presence of non-void return type</p>
                           </li>
                           <li>
                              <p>assignability degree of return value type</p>
                           </li>
                        </ul>
                     </div>
                     <p>
               The third rule, presence of non-void return type, states that JBoss AOP will give preference to an
               after advice that returns a value:
            </p>
                     <pre class="programlisting">&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;method(..))"&gt;
      &lt;after aspect="OneAspect" name="around"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public Collection after(@Arg int param0) {...} //1
   public List after(@Arg boolean param1) { ... } //2
   public void after(@Arg short param2) { ... }   //3
}</pre>
                     <p>
               Considering the same <code class="literal">POJO</code> class defined previously (with
               <code class="literal">public void method(int, boolean, short)</code>), all three overloade
               versions of <code class="literal">OneAspect.after()</code> advice wil be considered equivalent
               in the first two criteria. Hence, we move to the third rule, that states that
               JBoss AOP prefers an after advice that returns a value over another one that is
               <code class="literal">void</code>. So, in the example above, the third advice is ruled out,
               and JBoss AOP still has two advices to select. Moving to the next rule, he assignability
               degree of the return type, we have the same result as the
               <code class="literal">OneAspect.around()</code> advice: the first one has a 0 degree, and the second
               one, a 1 degree value. As a conclusion of these degrees, JBoss AOP will select the first
               advice, with the lowest return assignability degree.
            </p>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="adv-overlannotparammatch"/>4.4.1.4. A Match</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               Notice that, iIf JBoss AOP cannot find an advice with highest priority, it just selects one
               of the methods arbitrarily. This would be the case of the following advice method scenario:
            </p>
                     <pre class="programlisting">public class POJO
{
   public void method(int arg0, long arg1) {…}
}


&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="execution(* POJO-&gt;method(..))"&gt;
      &lt;before aspect="OneAspect" name="before"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;


public class OneAspect
{
   public void advice(@Arg int arg0) {}
   public void advice(@Arg long arg1) {}
}</pre>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="adv-overlannotparamlowest"/>4.4.1.5. Lowest Priority</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               There are exceptions for the rules we’ve seen. Advices with one or more of the following
               characteristics will be considered lowest priority, regardless of any other criteria:
            </p>
                     <div class="itemizedlist">
                        <ul>
                           <li>
                              <p>an advice that receives <code class="literal">@Target</code> parameter to intercept a joinpoint with no target available</p>
                           </li>
                           <li>
                              <p>an advice that receives <code class="literal">@Caller</code> parameter to intercept a joinpoint with no caller available</p>
                           </li>
                           <li>
                              <p>an advice that receives <code class="literal">@Arg</code> parameter to intercept a field read joinpoint</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-overldefaultsignature"/>4.4.2. Default Signature</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            For the default around advice signature (i.e., without annotated parameters), there is only one parameter
            to analyze, the invocation. So, the priority rules are very simple:
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
                           <p>presence of the invocation parameter</p>
                        </li>
                        <li>
                           <p>assignability degree of the invocation parameter.</p>
                        </li>
                     </ul>
                  </div>
                  <p>
            Lets revisit the example given in the beginning of this section, in augmented version:
         </p>
                  <pre class="programlisting">class POJO
{
   public int field;
   public POJO(){}
   public someMethod(){}
}


public class OneAspect
{
   public Object trace(MethodInvocation invocation) throws Throwable {...} //1
   public Object trace(ConstructorInvocation invocation) throws Throwable {...} //2
   public Object trace(Invocation invocation) throws Throwable {...} //3
   public Object trace() throws Throwable {...} //4
}


&lt;aop&gt;
   &lt;aspect class="OneAspect"/&gt;
   &lt;bind pointcut="all(POJO)"&gt;
      &lt;advice aspect="OneAspect" name="trace"/&gt;
   &lt;/bind&gt;
&lt;/aop&gt;</pre>
                  <p>
            The fourth advice above will never be called, considering the presence rule. It is the only
            one that lacks the <code class="literal">Invocation</code> parameter, and would be called only if all
            others were considered invalid in a scenario, which won’t happen in this example. By ruling
            out this advice with the presence rule, all other advices are equivalent: the invocation parameter
            is present in all of them. So, we need to move on to the assignability degree rule to select
            one of them. However, the assignability degree needs to be calculated accordingly to the joinpoint
            being intercepted. JBoss AOP needs to evaluate each joinpoint type to be intercepted to do the
            correct selection for each case.
         </p>
                  <p>
            Consider the interception of the constructor of <code class="literal">POJO</code>. In that case, the first advice
            is considered invalid, becase a <code class="literal">MethodInvocation</code> is not assignable from the invocation
            type that JBoss AOP will provide, <code class="literal">ConstrucorInvocation</code>. We are now left with the second
            and third advices. The second one has assignability degree of 0 on the invocation type. The third one,
            assignability degree of 1 (it takes one step in the hierarchy to go fom <code class="literal">ConstructorInvocation</code>
            to <code class="literal">Invocation</code>). So, in this case, JBoss AOP will select the second advice, because it
            is the valid advice with the lower assignability degree on the invocation.
         </p>
                  <p>
            Similary, to intercept the execution of <code class="literal">POJO.someMethod()</code>, JBoss AOP will consider the second
            advice invalid, because it is supposed to receive an invocation whose type is assignable from
            <code class="literal">MethodInvocation</code>. Since the first advice has an assignability degree of 0 on the
            invocation, and the third one, assignability degree of 1, JBoss AOP will select the first one.
         </p>
                  <p>
            Given that <code class="literal">Invocation</code> will always be the super class of the expected invocation type,
            JBoss AOP will select this advice, whose assignability degree will always be 1, only when the other two
            advices are invalid. That would be the case of a field read, where the invocation type is
            <code class="literal">FieldReadInvocation</code>.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="adv-overldiffsign"/>4.4.3. Mixing Different Signatures</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            Finally, when we mix default signature methods with annotated parameter ones, an advice in one of the forms:
         </p>
                  <pre class="programlisting">public Object [advice name]([Invocation] invocation) throws Throwable

public Object [advice name]([Invocation] invocation) throws Throwable

public Object [advice name]() throws Throable</pre>
                  <p>
            Has the highest priority over all annotated-parameter advices. If there is more than one with
            the default signature, the criteria described in the previous section will be used to select one of them..
         </p>
                  <p>
            Notice that mixing different signatures is possible only with around advices, since only these ones
            can follow the default signature.
         </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="adv-errors"/>4.5. Common Mistakes</h2>
                     </div>
                  </div>
               </div>
               <p>
         While writing advices and bindings, it is possible to make some mistakes,
         like, for example, mistyping the advice name, or writing an advice with an
         invalid signature.
      </p>
               <p>
         Whenever there is a mistake in the advice name or signature, JBoss AOP will
         throw an exception with a message stating the cause of the error.
         The exception thrown is a runtime exception and should not be treated.
         Instead, it indicates a mistake that must be fixed.
      </p>
               <p>
         There are two types of exceptions JBoss AOP can throw on those cases:
      </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="classname">org.jboss.InvalidAdviceException</code>
                        <p>
                This exception indicates that an advice's signature is considered
                invalid for the type used on the binding.
             </p>
                        <p>
                This can happen when the advice is mistakenly declared to be of the
                wrong type, or when one of the signature rules was not followed.
             </p>
                     </li>
                     <li>
                        <code class="classname">org.jboss.NoMatchingAdviceException</code>
                        <p>
                This exception is thrown when JBoss AOP can not find an advice method
                suitable for a specific joinpoint to be intercepted.
             </p>
                        <p>
                A possible scenario is when there is no advice method with the
                name used on the bind declaration. To solve it, just fix the advice
                name on the declaration or add a method with the declared advice name.
             </p>
                        <p>
                When there is one or more methods with the advice name, this exception
                indicates that JBoss was not able to find an advice with a signature
                that suits the joinpoint to be intercepted. In this case, the
                solution can be to alter the signature of one of the existent advice
                methods, or to add an overloaded advice method that matches the
                joinpoint to be intercepted.
             </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="xml"/>Chapter 5. XML Bindings</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-overview">5.1. Intro</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-resolving">5.2. Resolving XML</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-resolving1">5.2.1. Standalone XML Resolving</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-resolving2">5.2.2. Application Server XML Resolving</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-schema">5.3. XML Schema</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-aspect">5.4. aspect</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-aspect1">5.4.1. Basic Definition</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-aspect2">5.4.2. Scope</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-aspect3">5.4.3. Configuration</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-aspect4">5.4.4. Aspect Factories</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-interceptor">5.5. interceptor</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-bind">5.6. bind</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-stack">5.7. stack</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-pointcut">5.8. pointcut</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-introduction">5.9. introduction</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-introduction1">5.9.1. Interface introductions</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#xml-introduction2">5.9.2. Mixins</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-annotation-introduction">5.10. annotation-introduction</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-cflow">5.11. cflow-stack</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-typedef">5.12. typedef</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-dynamic">5.13. dynamic-cflow</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-prepare">5.14. prepare</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-metadata">5.15. metadata</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-metadata-loader">5.16. metadata-loader</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-precedence">5.17. precedence</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#xml-declare">5.18. declare</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#declare-warning">5.18.1. declare-warning</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#declare-error">5.18.2. declare-error</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
               </dl>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-overview"/>5.1. Intro</h2>
                     </div>
                  </div>
               </div>
               <p>
         In the last sections you saw how to
         code aspects and how pointcut expressions are formed.  This chapter puts it all together.  There are two
         forms of bindings for advices, mixins, and introductions.  One is XML which will be the focus of this chapter.
         The Annotated Bindings chapter discusses how you can replace XML with annotations.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-resolving"/>5.2. Resolving XML</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AOP resolves pointcut and advice bindings at runtime.  So, bindings are a deployment time thing.  How
         does JBoss AOP find the XML files it needs at runtime?  There are a couple of ways.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-resolving1"/>5.2.1. Standalone XML Resolving</h3>
                        </div>
                     </div>
                  </div>
                  <p>
         When you are running JBoss AOP outside of the application server there are a few ways that the JBoss AOP
         framework can resolve XML files.
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
                           <code class="literal">jboss.aop.path</code> This is a system property that is a ';' (Windows) or ':' (Unix)
               delimited list of XML files and/or directories.  If the item in the list is a directory, JBoss AOP
               will load any xml file in those directories with the filename suffix
               <code class="literal">-aop.xml</code>
                        </li>
                        <li>
                           <code class="literal">META-INF/jboss-aop.xml</code> Any JAR file in your CLASSPATH that has a
               <code class="literal">jboss-aop.xml</code>
               file in the
               <code class="literal">META-INF/</code> will be loaded.  JBoss AOP does a
               <code class="literal">ClassLoader.getResources("META-INF/jboss-aop.xml")</code> to obtain all these files.
            </li>
                     </ul>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-resolving2"/>5.2.2. Application Server XML Resolving</h3>
                        </div>
                     </div>
                  </div>
                  <p>
         On the other hand, when you are running JBoss AOP integrated with the
            application server, XML files can be deployed in two different ways.
            One is to place an XML file with the suffix
            <code class="literal">*-aop.xml</code>
            in the deploy directory.  The other way is to JAR up your classes and provide a
            <code class="literal">META-INF/jboss-aop.xml</code>
            file in this JAR.  This JAR file must be suffixed with
            <code class="literal">.aop</code> and placed within the deploy/
            directory or embedded as a nested archive.
         </p>
                  <p>
            Note that in JBoss 5, you MUST specify the schema used, otherwise your information will not be
            parsed correctly. You do this by adding the <code class="literal">xmlns="urn:jboss:aop-beans:1:0</code> 
            attribute to the root <code class="literal">aop</code> element, as shown here: 
            </p>
                  <pre class="programlisting">
&lt;aop xmlns="urn:jboss:aop-beans:1.0"&gt;
&lt;!--  The exact contents will be explained below --&gt;
&lt;/aop&gt;
            
            </pre>
                  <p>
         
                  </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-schema"/>5.3. XML Schema</h2>
                     </div>
                  </div>
               </div>
               <p>
         The xml schema can be found in the distribution's <code class="literal">etc/</code>literal&gt; folder.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-aspect"/>5.4. aspect</h2>
                     </div>
                  </div>
               </div>
               <p>
         The
         <code class="literal">&lt;aspect&gt;</code> tag specifies to the AOP container to declare an aspect
         class.  It is also used for configuring aspects as they are created and defining the scope of the
         aspects instance.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-aspect1"/>5.4.1. Basic Definition</h3>
                        </div>
                     </div>
                  </div>
                  <pre class="programlisting">&lt;aspect class="org.jboss.MyAspect"/&gt;</pre>
                  <p>
            In a basic declaration you specify the fully qualified class name of the aspect.  If you want to reference
            the aspect at runtime through the AspectManager, the name of the aspect is the same name as the class name.
            The default Scope of this aspect is
            <code class="literal">PER_VM</code>.  Another important note is that aspect instances are created on demand and NOT
            at deployment time.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-aspect2"/>5.4.2. Scope</h3>
                        </div>
                     </div>
                  </div>
                  <pre class="programlisting">&lt;aspect class="org.jboss.MyAspect" scope="PER_VM"/&gt;</pre>
                  <p>
            The
            <code class="literal">scope</code> attribute defines when an instance of the aspect should be created.  An aspect
            can be created per vm, per class, per instance, or per joinpoint.
            </p>
                  <div class="table">
                     <a id="scopetable"/>
                     <div class="table-contents">
                        <table summary="&#xA;                 Aspect instance scope&#xA;               " border="1">
                           <colgroup>
                              <col/>
                              <col/>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th align="center">
                             Name
                        </th>
                                 <th align="center">
                             Description
                        </th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td>
                             PER_VM
                        </td>
                                 <td>
                             One and only instance of the aspect class is allocated for the entire VM.
                        </td>
                              </tr>
                              <tr>
                                 <td>
                             PER_CLASS
                        </td>
                                 <td>
                             One and only instance of the aspect class is allocated for a particular class.  This
                           instance will be created if an advice of that aspect is bound to that particular class.
                        </td>
                              </tr>
                              <tr>
                                 <td>
                             PER_INSTANCE
                        </td>
                                 <td>
                             An instance of an aspect will be created per advised object instance.  For instance,
                             if a method has an advice attached to it, whenever an instance of that advised class
                             is allocated, there will also be one created for the aspect.
                        </td>
                              </tr>
                              <tr>
                                 <td>
                             PER_JOINPOINT
                        </td>
                                 <td>
                             An instance of an aspect will be created per joinpoint advised.  If the joinpoint is a
                             static member (constructor, static field/method), then there will be one instance of the
                             aspect created per class, per joinpoint.  If the joinpoint is a regular non-static member,
                             than an instance of the aspect will be created per object instance, per joinpoint.
                        </td>
                              </tr>
                              <tr>
                                 <td>
                             PER_CLASS_JOINPOINT
                        </td>
                                 <td>
                             An instance of an aspect will be created per advised joinpoint. The aspect instance is 
                             shared between all instances of the class (for that joinpoint).
                        </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <p class="title">
                        <b>Table 5.1. 
                 Aspect instance scope
               </b>
                     </p>
                  </div>
                  <p>
                     <br class="table-break"/>

         
                  </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-aspect3"/>5.4.3. Configuration</h3>
                        </div>
                     </div>
                  </div>
                  <pre class="programlisting">&lt;aspect class="org.jboss.SomeAspect"&gt;
     &lt;attribute name="SomeIntValue"&gt;55&lt;/attribute&gt;
     &lt;advisor-attribute name="MyAdvisor"/&gt;
     &lt;instance-advisor-attribute name="MyInstanceAdvisor"/&gt;
     &lt;joinpoint-attribute name="MyJoinpoint"/&gt;
&lt;/aspect&gt;</pre>
                  <p>
            Aspects can be configured by default using a Java Beans style convention. The
            <code class="literal">&lt;attribute&gt;</code>
            tag will delegate to a setter method and convert the string value to the type of the setter method.
         </p>
                  <div class="table">
                     <a id="javabeantypes"/>
                     <div class="table-contents">
                        <table summary="&#xA;              Supported Java Bean types&#xA;            " border="1">
                           <colgroup>
                              <col/>
                           </colgroup>
                           <tbody>
                              <tr>
                                 <td>primitive types (int, float, String, etc...)</td>
                              </tr>
                              <tr>
                                 <td>java.lang.Class</td>
                              </tr>
                              <tr>
                                 <td>java.lang.Class[]</td>
                              </tr>
                              <tr>
                                 <td>java.lang.String[]</td>
                              </tr>
                              <tr>
                                 <td>java.math.BigDecimal</td>
                              </tr>
                              <tr>
                                 <td>org.w3c.dom.Document</td>
                              </tr>
                              <tr>
                                 <td>java.io.File</td>
                              </tr>
                              <tr>
                                 <td>java.net.InetAddress</td>
                              </tr>
                              <tr>
                                 <td>java.net.URL</td>
                              </tr>
                              <tr>
                                 <td>javax.management.ObjectName (if running in JBoss)</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <p class="title">
                        <b>Table 5.2. 
              Supported Java Bean types
            </b>
                     </p>
                  </div>
                  <br class="table-break"/>
                  <p>
            Besides types, you can also inject AOP runtime constructs into the aspect.  These types of attributes
            are referenced within XML under special tags.  See the table below.
         </p>
                  <div class="table">
                     <a id="aop-attributes"/>
                     <div class="table-contents">
                        <table summary="&#xA;              Injecting AOP runtime constructs&#xA;            " border="1">
                           <colgroup>
                              <col/>
                              <col/>
                           </colgroup>
                           <tbody>
                              <tr>
                                 <td>&lt;advisor-attribute&gt;</td>
                                 <td>org.jboss.aop.Advisor</td>
                              </tr>
                              <tr>
                                 <td>&lt;instance-advisor-attribute&gt;</td>
                                 <td>org.jboss.aop.InstanceAdvisor</td>
                              </tr>
                              <tr>
                                 <td>&lt;joinpoint-attribute&gt;</td>
                                 <td>org.jboss.aop.joinpoint.Joinpoint</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <p class="title">
                        <b>Table 5.3. 
              Injecting AOP runtime constructs
            </b>
                     </p>
                  </div>
                  <br class="table-break"/>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="xml-config-names"/>5.4.3.1. Names</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               If there
         is no
               <code class="literal">name</code> attribute defined, the name of the aspect is the same as the
               <code class="literal">class</code> or
               <code class="literal">factory</code> attribute value.
            </p>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="xml-config-example"/>5.4.3.2. Example configuration</h4>
                           </div>
                        </div>
                     </div>
                     <pre class="programlisting">&lt;aspect class="org.jboss.SomeAspect"&gt;
        &lt;attribute name="SomeIntValue"&gt;55&lt;/attribute&gt;
        &lt;advisor-attribute name="MyAdvisor"/&gt;
        &lt;instance-advisor-attribute name="MyInstanceAdvisor"/&gt;
        &lt;joinpoint-attribute name="MyJoinpoint"/&gt;
&lt;/aspect&gt;</pre>
                     <p>
               The above example would would need a class implemented as follows:
            </p>
                     <pre class="programlisting">public class SomeAspect {
   public SomeAspect() {}

   public void setSomeIntValue(int val) {...}
   public void setMyAdvisor(org.jboss.aop.Advisor advisor) {...}
   public void setMyInstanceAdvisor(org.jboss.aop.InstanceAdvisor advisor) {...}
   public void setMyJoinpoint(org.jboss.aop.joinpoint.Joinpoint joinpoin) {...}
}</pre>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-aspect4"/>5.4.4. Aspect Factories</h3>
                        </div>
                     </div>
                  </div>
                  <pre class="programlisting">
&lt;aspect name="MyAspect" factory="org.jboss.AspectConfigFactory" scope="PER_CLASS"&gt;
     &lt;some-arbitrary-xml&gt;value&lt;/some-arbitrary-xml&gt;
&lt;/aspect&gt;</pre>
                  <p>If you do not like the default Java Bean configuration for aspects, or want to delegate aspect
         creation to some other container, you can plug in your own factory class by specifying the
            <code class="literal">factory</code> attribute rather than the
            <code class="literal">class</code> attribute.  Any arbitrary
            XML can be specified in the aspect XML declaration and it will be passed to the factory class.
            Factories must implement the
            <code class="literal">org.jboss.aop.advice.AspectFactory</code> interface.
         </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-interceptor"/>5.5. interceptor</h2>
                     </div>
                  </div>
               </div>
               <pre class="programlisting">
&lt;interceptor class="org.jboss.MyInterceptor" scope="PER_VM"/&gt;
&lt;interceptor class="org.jboss.SomeInterceptor"&gt;
     &lt;attribute name="SomeIntValue"&gt;55&lt;/attribute&gt;
     &lt;advisor-attribute name="MyAdvisor"/&gt;
     &lt;instance-advisor-attribute name="MyInstanceAdvisor"/&gt;
     &lt;joinpoint-attribute name="MyJoinpoint"/&gt;
&lt;/interceptor&gt;
&lt;interceptor name="MyAspect" factory="org.jboss.InterceptorConfigFactory" scope="PER_CLASS"&gt;
  &lt;some-arbitrary-xml&gt;value&lt;/some-arbitrary-xml&gt;
&lt;/interceptor&gt;</pre>
               <p>
         Interceptors are defined in XML the same exact way as aspects are.  No difference except the tag.  If there
         is no
         <code class="literal">name</code> attribute defined, the name of the interceptor is the same as the
         <code class="literal">class</code> or
         <code class="literal">factory</code> attribute value.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-bind"/>5.6. bind</h2>
                     </div>
                  </div>
               </div>
               <pre class="programlisting">&lt;bind pointcut="execution(void Foo-&gt;bar())"&gt;
      &lt;interceptor-ref name="org.jboss.MyInterceptor/&gt;
      &lt;before name="beforeAdvice" aspect="org.jboss.MyAspect"/&gt;
      &lt;around name="aroundAdvice" aspect="org.jboss.MyAspect"/&gt;
      &lt;after name="afterAdvice" aspect="org.jboss.MyAspect"/&gt;
      &lt;throwing name="throwingAdvice" aspect="org.jboss.MyAspect"/&gt;
      &lt;finally name="finallyAdvice" aspect="org.jboss.MyAspect"/&gt;
      &lt;advice name="trace" aspect="org.jboss.MyAspect"/&gt;
&lt;/bind&gt;</pre>
               <p>
         In the above example, the <code class="literal">MyInterceptor</code> interceptor and several advice methods
         of the <code class="literal">MyAspect</code> class will be executed when the <code class="literal">Foo.bar</code> method is invoked.
      </p>
               <div class="variablelist">
                  <dl>
                     <dt>
                        <span class="term">bind</span>
                     </dt>
                     <dd>
                        <p>
                  
                           <code class="literal">bind</code> tag is used to bind an advice of an aspect, or an interceptor to a specific joinpoint.
                  The
                  <code class="literal">pointcut</code> attribute is required and at least an advice or interceptor-ref definition.
               </p>
                     </dd>
                     <dt>
                        <span class="term">interceptor-ref</span>
                     </dt>
                     <dd>
                        <p>
               The
                  <code class="literal">interceptor-ref</code> tag must reference an already existing
                  <code class="literal">interceptor</code> XML
          definition.  The name attribute should be the name of the interceptor you are referencing.
               </p>
                     </dd>
                     <dt>
                        <span class="term">before, around, after, throwing and finally</span>
                     </dt>
                     <dd>
                        <p>
               All these tags take a
                  <code class="literal">name</code> attribute that should map to an advice of the specified type within
               the aspect class.  The <code class="literal">aspect</code> attribute should be the name of the aspect definition.
               </p>
                     </dd>
                     <dt>
                        <span class="term">advice</span>
                     </dt>
                     <dd>
                        <p>
                  The same as the previous, except for the fact that doesn't specify the type of the advice. This
                  tag selects the default advice type, around, and is hence equivalent to the tag <code class="literal">around</code>.
               </p>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-stack"/>5.7. stack</h2>
                     </div>
                  </div>
               </div>
               <p>
         Stacks allow you to define a predefined set of advices/interceptors that you want to reference from within
         a
         <code class="literal">bind</code> element.
      </p>
               <pre class="programlisting">&lt;stack name="stuff"&gt;
      &lt;interceptor class="SimpleInterceptor1" scope="PER_VM"/&gt;
      &lt;advice name="trace" aspect="org.jboss.TracingAspect"/&gt;
      &lt;interceptor class="SimpleInterceptor3"&gt;
           &lt;attribute name="size"&gt;55&lt;/attribute&gt;
      &lt;/interceptor&gt;
&lt;/stack&gt;</pre>
               <p>
         After defining the stack you can then reference it from within a
         <code class="literal">bind</code> element.
      </p>
               <pre class="programlisting">&lt;bind pointcut="execution(* POJO-&gt;*(..))"&gt;
       &lt;stack-ref name="stuff"/&gt;
&lt;/bind&gt;</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-pointcut"/>5.8. pointcut</h2>
                     </div>
                  </div>
               </div>
               <p>
         The
         <code class="literal">pointcut</code> tag allows you to define a pointcut expression, name it and reference it
         within any binding you want.  It is also useful to publish pointcuts into your applications to that others
         have a clear set of named integration points.
      </p>
               <pre class="programlisting">&lt;pointcut name="publicMethods" expr="execution(public * *-&gt;*(..))"/&gt;
&lt;pointcut name="staticMethods" expr="execution(static * *-&gt;*(..))"/&gt;</pre>
               <p>
         The above define two different pointcuts.  One that matches all public methods, the other that matches
         the execution of all static methods.  These two pointcuts can then be referenced within a
         <code class="literal">bind</code>
         element.
      </p>
               <pre class="programlisting">&lt;bind pointcut="publicMethods AND staticMethods"&gt;
      &lt;interceptor-ref name="tracing"/&gt;
&lt;/bind&gt;
         </pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-introduction"/>5.9. introduction</h2>
                     </div>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-introduction1"/>5.9.1. Interface introductions</h3>
                        </div>
                     </div>
                  </div>
                  <p>
         The
            <code class="literal">introduction</code> tag allows you to force an existing Java class to implement a particular
         defined interface.
         </p>
                  <pre class="programlisting">&lt;introduction class="org.acme.MyClass"&gt;
    &lt;interfaces&gt;java.io.Serializable&lt;/interfaces&gt;
&lt;/introduction&gt;</pre>
                  <p>
            The above declaration says that the org.acme.MyClass class will be forced to implement java.io.Serializable.
            The
            <code class="literal">class</code> attribute can take wildcards but not boolean expressions.  If you need more
            complex type expressions, you can use the
            <code class="literal">expr</code> attribute instead.
         </p>
                  <pre class="programlisting">&lt;introduction expr="has(* *-&gt;@test(..)) OR class(org.acme.*)"&gt;
    &lt;interfaces&gt;java.io.Serializable&lt;/interfaces&gt;
&lt;/introduction&gt;</pre>
                  <p>
            The
            <code class="literal">expr</code> can be any type expression allowed in a
            <code class="literal">typedef</code> expression
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="xml-introduction2"/>5.9.2. Mixins</h3>
                        </div>
                     </div>
                  </div>
                  <p>
         When introducing an interface you can also define a mixin class which will provide the implementation
         of that interface.
         </p>
                  <pre class="programlisting">&lt;introduction class="org.acme.MyClass"&gt;
      &lt;mixin&gt;
         &lt;interfaces&gt;
            java.io.Externalizable
         &lt;/interfaces&gt;
         &lt;class&gt;org.acme.ExternalizableMixin&lt;/class&gt;
         &lt;construction&gt;new org.acme.ExternalizableMixin(this)&lt;/construction&gt;
      &lt;/mixin&gt;
   &lt;/introduction&gt;</pre>
                  <div class="variablelist">
                     <dl>
                        <dt>
                           <span class="term">interfaces</span>
                        </dt>
                        <dd>
                           <p>defines the list of interfaces you are introducing</p>
                        </dd>
                        <dt>
                           <span class="term">class</span>
                        </dt>
                        <dd>
                           <p>The type of the mixin class.</p>
                        </dd>
                        <dt>
                           <span class="term">construction</span>
                        </dt>
                        <dd>
                           <p>The construction statement allows you to specify any Java code to create the mixin class.
            This code will be embedded directly in the class you are introducing to so
                     <code class="literal">this</code>
            works in the construction statement.
                  </p>
                        </dd>
                     </dl>
                  </div>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-annotation-introduction"/>5.10. annotation-introduction</h2>
                     </div>
                  </div>
               </div>
               <p>
        Annotation introductions allow you to embed an annotation within a the class file of the class.  You can
        introduce an annotation to a class, method, field, or constructor.
      </p>
               <pre class="programlisting">&lt;annotation-introduction expr="constructor(POJO-&gt;new())"&gt;
      @org.jboss.complex (ch='a', string="hello world", flt=5.5, dbl=6.6, shrt=5, lng=6, \
      integer=7, bool=true, annotation=@single("hello"), array={"hello", "world"}, \
      clazz=java.lang.String)
&lt;/annotation-introduction&gt;</pre>
               <p>
         The
         <code class="literal">expr</code> attribute takes method(), constructor(), class(), or field().  Within those you must define
         a valid expression for that construct.

         The following rules must be followed for the annotation declaration:
      </p>
               <div class="itemizedlist">
                  <ul>
                     <li>Any annotation, Class or Enum referenced, MUST be fully qualified.</li>
                  </ul>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-cflow"/>5.11. cflow-stack</h2>
                     </div>
                  </div>
               </div>
               <p>
         Control flow is a runtime construct.  It allows you to specify pointcut parameters revolving around the call
         stack of a Java program.  You can do stuff like, if method A calls method B calls Method C calls Method D from
         Constructor A, trigger this advice.

         In defining a control flow, you must first paint a picture of what the Java call stack should look like.  This
         is the responsibility of the cflow-stack.
      </p>
               <pre class="programlisting">&lt;cflow-stack name="recursive2"&gt;
      &lt;called expr="void POJO-&gt;recursive(int)"/&gt;
      &lt;called expr="void POJO-&gt;recursive(int)"/&gt;
      &lt;not-called expr="void POJO-&gt;recursive(int)"/&gt;
&lt;/cflow-stack&gt;</pre>
               <p>
         A
         <code class="literal">cflow-stack</code> has a name and a bunch of
         <code class="literal">called</code> and
         <code class="literal">not-called</code>
         elements that define individual constructor or method calls with a Java call stack.  The
         <code class="literal">expr</code>
         attribute must be a method or constructor expression.
         <code class="literal">called</code> states that the expr must be in the
         call stack.
         <code class="literal">not-called</code> states that there should not be any more of the expression within the stack.
         In the above example, the
         <code class="literal">cflow-stack</code> will be triggered if there are two and only two calls
         to the
         <code class="literal">recursive</code> method within the stack.

         Once the
         <code class="literal">cflow-stack</code> has been defined, it can then be referenced within a
         <code class="literal">bind</code>
         element through the
         <code class="literal">cflow</code> attribute.  Boolean expressions are allowed here as well.
      </p>
               <pre class="programlisting">&lt;bind pointcut="execution(void POJO-&gt;recursive(int))" cflow="recursive2 AND !cflow2"&gt;
      &lt;interceptor class="SimpleInterceptor"/&gt;
&lt;/bind&gt;</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-typedef"/>5.12. typedef</h2>
                     </div>
                  </div>
               </div>
               <pre class="programlisting">
&lt;typedef name="jmx" expr="class(@org.jboss.jmx.@MBean) OR \
                          has(* *-&gt;org.jboss.jmx.@ManagedOperation) OR \
                          has(* *-&gt;org.jboss.jmx.@ManagedAttribute)"/&gt;</pre>
               <p>
         
                  <code class="literal">typedef</code>s allow you to define complex type expressions and then use then pointcut expressions.
          In the above example, we're defining a class that is tagged as @Mbean, or has a method tagged as @ManagedOperaion
          or @ManagedAttribute.

          The above typedef could then be used in a pointcut, introduction, or bind element
      </p>
               <pre class="programlisting">&lt;pointcut name="stuff" expr="execution(* $typedef{jmx}-&gt;*(..))"/&gt;
&lt;introduction expr="class($typedef{jmx})"&gt;</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-dynamic"/>5.13. dynamic-cflow</h2>
                     </div>
                  </div>
               </div>
               <p>
         
                  <code class="literal">dynamic-cflow</code> allows you to define code that will be executed that must be resolved true to trigger
         positive on a cflow test on an advice binding. The test happens dynamically at runtime and when combined with a pointcut expression allows you to
         do runtime checks on whether a advice binding should run or not.  Create a dynamic cflow class, by implementing the following interface.
         </p>
               <pre class="programlisting">
package org.jboss.aop.pointcut;

import org.jboss.aop.joinpoint.Invocation;

/**
 * Dynamic cflow allows you to programmatically check to see if
 * you want to execute a given advice binding.
 *
 * @author <span class="ERROR">&lt;a&gt;Bill Burke&lt;/a&gt;</span>
 * @version $Revision: 79662 $
 *
 **/
public interface DynamicCFlow
{
   boolean shouldExecute(Invocation invocation);
}
         </pre>
               <p>
         
         You must declare it with XML so that it can be used in bind expressions.
      </p>
               <pre class="programlisting">&lt;dynamic-cflow name="simple" class="org.jboss.SimpleDynamicCFlow"/&gt;</pre>
               <p>
         You can then use it within a
         <code class="literal">bind</code>
      
               </p>
               <pre class="programlisting">&lt;bind expr="execution(void Foo-&gt;bar())" cflow="simple"&gt;</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-prepare"/>5.14. prepare</h2>
                     </div>
                  </div>
               </div>
               <p>
         The
         <code class="literal">prepare</code> tag allows you to define a pointcut expression.  Any joinpoint that matches
         the expression will be aspectized and bytecode instrumented.  This allows you to hotdeploy and bind
         aspects at runtime as well as to work with the per instance API that every aspectized class has.

         To prepare something, just define a pointcut expression that matches the joinpoint you want to instrument.
      </p>
               <pre class="programlisting">&lt;prepare expr="execution(void Foo-bar())"/&gt;</pre>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-metadata"/>5.15. metadata</h2>
                     </div>
                  </div>
               </div>
               <p>
         You can attach untyped metadata that is stored in
         <code class="literal">org.jboss.aop.metadata.SimpleMetaData structures</code>
         within the
         <code class="literal">org.jboss.aop.Advisor</code> class that manages each aspectized class.  The XML mapping
         has a section for each type of metadata.  Class, method, constructor, field, and defaults for the whole shabang.

         Here's an example:
      </p>
               <pre class="programlisting">&lt;metadata tag="testdata" class="org.jboss.test.POJO"&gt;
      &lt;default&gt;
         &lt;some-data&gt;default value&lt;/some-data&gt;
      &lt;/default&gt;
      &lt;class&gt;
         &lt;data&gt;class level&lt;/data&gt;
      &lt;/class&gt;
      &lt;constructor expr="POJOConstructorTest()"&gt;
         &lt;some-data&gt;empty&lt;/some-data&gt;
      &lt;/constructor&gt;
      &lt;method expr="void another(int, int)"&gt;
         &lt;other-data&gt;half&lt;/other-data&gt;
      &lt;/method&gt;
      &lt;field name="somefield"&gt;
         &lt;other-data&gt;full&lt;/other-data&gt;
      &lt;/field&gt;
&lt;/metadata&gt;</pre>
               <p>
         Any element can be defined under the class, default, method, field, and constructor tags.  The name of these elements
         are used as attribute names in SimpleMetaData structures.

         The
         <code class="literal">tag</code> attribute is the name used to reference the metadata within the Advisor, or Invocation
         lookup mechanisms.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-metadata-loader"/>5.16. metadata-loader</h2>
                     </div>
                  </div>
               </div>
               <pre class="programlisting">&lt;metadata-loader tag="security" class="org.jboss.aspects.security.SecurityClassMetaDataLoader"/&gt;</pre>
               <p>
         If you need more complex XML mappings for untyped metadata, you can write your own metadata binding.  The tag
         attribute is used to trigger the loader.  The loader class must implement the
         <code class="literal">org.jboss.aop.metadata.ClassMetaDataLoader</code>
         interface.
      </p>
               <pre class="programlisting">public interface ClassMetaDataLoader
{
   public ClassMetaDataBinding importMetaData(Element element, String name,
                                              String tag, String classExpr) throws Exception;

   public void bind(ClassAdvisor advisor, ClassMetaDataBinding data,
                    CtMethod[] methods, CtField[] fields, CtConstructor[] constructors) \
                    throws Exception;

   public void bind(ClassAdvisor advisor, ClassMetaDataBinding data,
                    Method[] methods, Field[] fields, Constructor[] constructors) \ 
                    throws Exception;
}</pre>
               <p>
          Any arbitrary XML can be in the
         <code class="literal">metadata</code> element.  The ClassMetaDataBinding.importMetaData
          method is responsible for parsing the element and building ClassMetaDataBinding structurs which are
          used in the precompiler and runtime bind steps.  Look at the SecurityClassMetaDataLoader code shown above
          for a real concrete example.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-precedence"/>5.17. precedence</h2>
                     </div>
                  </div>
               </div>
               <p>Precedence allows you to impose an overall relative sorting order of your interceptors and advices.</p>
               <pre class="programlisting">         &lt;precedence&gt;
            &lt;interceptor-ref name="org.acme.Interceptor"/&gt;
            &lt;advice aspect="org.acme.Aspect" name="advice1"/&gt;
            &lt;advice aspect="org.acme.Aspect" name="advice2"/&gt;
         &lt;/precedence&gt;         
      </pre>
               <p>
         This says that when a joinpoint has both <code class="literal">org.acme.Interceptor</code> and 
         <code class="literal">org.acme.Aspect.advice()</code> bound to it, <code class="literal">org.acme.Interceptor</code> 
         must always be invoked before <code class="literal">org.acme.Aspect.advice1()</code> which must in turn be 
         invoked before <code class="literal">org.acme.Aspect.advice2()</code>. The ordering of 
         interceptors/advices that do not appear in a precedence is defined by their ordering for the 
         individual bindings or intercerceptor stacks. 
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="xml-declare"/>5.18. declare</h2>
                     </div>
                  </div>
               </div>
               <p>
         You can declare checks to be enforced at instrumentation time. They take a pointcut and a message. 
         If the pointcut is matched, the message is printed out.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="declare-warning"/>5.18.1. declare-warning</h3>
                        </div>
                     </div>
                  </div>
                  <pre class="programlisting">   &lt;declare-warning expr="class($instanceof{VehicleDAO}) \
            AND !has(public void *-&gt;save())"&gt;
         All VehicleDAO subclasses must override the save() method.
   &lt;/declare-warning&gt; </pre>
                  <p>
            The above declaration says that if any subclass of VehicleDAO does not implement a noargs save() method, a 
            warning with the supplied message should be logged. Your application will continue to be instrumented/run 
            (since we are using <code class="literal">declare-warning</code> in this case).
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="declare-error"/>5.18.2. declare-error</h3>
                        </div>
                     </div>
                  </div>
                  <pre class="programlisting">      &lt;declare-error expr="call(* org.acme.businesslayer.*-&gt;*(..)) \
            AND within(org.acme.datalayer.*)"&gt;
      Data layer classes should not call up to the business layer
   &lt;/declare-error&gt; </pre>
                  <p>
            The above declaration says that if any classes in the datalayer call classes in the business layer of your application, 
            an error should be thrown. Instumentation/execution of your application will stop. 
         </p>
               </div>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="annotated"/>Chapter 6. Annotation Bindings</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-aspect">6.1. @Aspect</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-interceptor">6.2. @InterceptorDef</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#annotated-interceptor-interceptor">6.2.1. Interceptor Example</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#annotated-interceptor-factory">6.2.2. AspectFactory Example</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-pointcut">6.3. @PointcutDef</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-bind">6.4. @Bind</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-introduction">6.5. @Introduction</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-mixin">6.6. @Mixin</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-prepare">6.7. @Prepare</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#annotated-prepare-pojo">6.7.1. @Prepare POJO</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-typedef">6.8. @TypeDef</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-cflow">6.9. @CFlowDef</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-dynamiccflow">6.10. @DynamicCFlowDef</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-annotationintro">6.11. @AnnotationIntroductionDef</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-precedence">6.12. @Precedence</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#annotated-declare">6.13. @DeclareError and @DeclareWarning</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <p>
         Annotations can be used as an alternative to XML for configuring classes for AOP. 
   </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-aspect"/>6.1. @Aspect</h2>
                     </div>
                  </div>
               </div>
               <p>
         To mark a class as an aspect you annotate it with the
         <code class="literal">@Aspect</code> annotation.
         Remember that a class to be used as an aspect does not need to inherit or implement anything special,
         but it must have an empty constuctor and contain one or more methods (advices) of the format:
         </p>
               <pre class="programlisting">public Object &lt;any-method-name&gt;(org.jboss.aop.joinpoint.Invocation)</pre>
               <p>
      
               </p>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.Aspect</code> is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   import org.jboss.aop.advice.Scope;
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;


   @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME)
           public @interface Aspect
   {
      Scope scope() default Scope.PER_VM;
   }

         </pre>
               <p>
         and Scope is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop.advice;

   public enum Scope
   {
      PER_VM, PER_CLASS, PER_INSTANCE, PER_JOINPOINT
   }
         </pre>
               <p>
         See <a href="#xml-aspect2" title="5.4.2. Scope">Section 5.4.2, “Scope”</a> for a description of the various scopes.
      </p>
               <p>
         We use the @Aspect annotation as follows:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.Aspect;
   import org.jboss.aop.advice.Scope;
   import org.jboss.aop.joinpoint.Invocation;

   @Aspect (scope = Scope.PER_VM)
   public class MyAspect
   {
      public Object myAdvice(Invocation invocation)
   }

         </pre>
               <p>
      
               </p>
               <p>
         The name of the class (in this case <code class="literal">com.mypackage.MyAspect</code>) gets used as the
         internal name of the aspect. The equivalent using XML configuration would be:
         </p>
               <pre class="programlisting">
            &lt;aop&gt;
            &lt;aspect class="com.mypackage.MyAspect" scope="PER_VM"/&gt;
            &lt;/aop&gt;
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-interceptor"/>6.2. @InterceptorDef</h2>
                     </div>
                  </div>
               </div>
               <p>
         To mark a class as an interceptor or an aspect factory you annotate it with the
         <code class="literal">@InterceptorDef</code> annotation. The class must either implement
         the
         <code class="literal">org.jboss.aop.advice.Interceptor</code> interface or the
         <code class="literal">org.jboss.aop.advice.AspectFactory</code> interface.
      </p>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.InterceptorDef</code> is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME)
           public @interface Aspect
   {
      Scope scope() default Scope.PER_VM;
   }

         </pre>
               <p>
         The same
         <code class="literal">Scope</code> enum is used as for
         <code class="literal">Aspect</code>.
         The following examples use the @Bind annotation, which will be described in more
         detail below.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="annotated-interceptor-interceptor"/>6.2.1. Interceptor Example</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            We use the
            <code class="literal">@InterceptorDef</code> annotation to mark
            an Interceptor as follows:
            </p>
                  <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.Bind;
   import org.jboss.aop.InterceptorDef;
   import org.jboss.aop.advice.Interceptor;

   @InterceptorDef (scope = Scope.PER_VM)
   @Bind (pointcut="execution("* com.blah.Test-&gt;test(..)")
   public class MyInterceptor implements Interceptor
   {
      public Object invoke(Invocation invocation)throws Throwable
      {
         return invocation.invokeNext();
      }
   }

            </pre>
                  <p>
         
                  </p>
                  <p>
         The name of the class (in this case <code class="literal">com.mypackage.MyInterceptor</code>) gets used as the
         class name of the interceptor. The equivalent using XML configuration would be:
            </p>
                  <pre class="programlisting">
               &lt;aop&gt;
               &lt;interceptor class="com.mypackage.MyInterceptor" scope="PER_VM"/&gt;
               &lt;/aop&gt;
            </pre>
                  <p>
         
                  </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="annotated-interceptor-factory"/>6.2.2. AspectFactory Example</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            The <code class="literal">@InterceptorDef</code> annotation is used to mark an
            AspectFactory as follows:
            </p>
                  <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.advice.AspectFactory;

   @InterceptorDef (scope=org.jboss.aop.advice.Scope.PER_VM)
   @Bind (pointcut="execution("* com.blah.Test-&gt;test2(..)")
   public class MyInterceptorFactory implements AspectFactory
   {
      //Implemented methods left out for brevity
   }
            </pre>
                  <p>
         
                  </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-pointcut"/>6.3. @PointcutDef</h2>
                     </div>
                  </div>
               </div>
               <p>
         To define a named pointcut you annotate a field within an
         <code class="literal">@Aspect</code>
         or
         <code class="literal">@InterceptorDef</code> annotated class with
         <code class="literal">@PointcutDef</code>.
         <code class="literal">@PointcutDef</code> only applies to fields and is not recognised outside
         <code class="literal">@Aspect</code> or
         <code class="literal">@InterceptorDef</code> annotated classes.
      </p>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.PointcutDef</code> is:
         </p>
               <pre class="programlisting">
package org.jboss.aop;

@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
public @interface PointcutDef
{
   String value();
}</pre>
               <p>
         
                  <code class="literal">@PointcutDef</code> takes only one value, a valid pointcut expression.
         The name of the pointcut used internally and when yo want to reference it is:
         </p>
               <pre class="programlisting">&lt;name of @Aspect/@InterceptorDef annotated class&gt;.&lt;name of @PointcutDef annotated field&gt;</pre>
               <p>
      
               </p>
               <p>
         An example of an aspect class containing a named pointcut which it references from
         a bindng's pointcut expression:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.PointcutDef;
   import org.jboss.aop.pointcut.Pointcut;

   @Aspect (scope = Scope.PER_VM)
   public class MyAspect
   {
      @PointcutDef ("(execution(* org.blah.Foo-&gt;someMethod()) OR \
	      execution(* org.blah.Foo-&gt;otherMethod()))")
      public static Pointcut fooMethods;

      public Object myAdvice(Invocation invocation)
      {
         return invocation.invokeNext();
      }
   }
         </pre>
               <p>
         It is worth noting that named pointcuts can be referenced in pointcut expressions
         outside the class they are declared in (if the annotated fields are declared
         public of course!).
      </p>
               <p>
         Using XML configuration this would be:
         </p>
               <pre class="programlisting">
            &lt;aop&gt;
            &lt;aspect class="com.mypackage.MyAspect" scope="PER_VM"/&gt;
            &lt;pointcut
            name="com.mypackage.MyAspect.fooMethods"
            expr="(execution(* org.blah.Foo-&gt;someMethod()) OR \
                  execution(* org.blah.Foo-&gt;otherMethod()))"
      /&gt;
            &lt;/aop&gt;
         </pre>
               <p>
         
                  <code class="literal"/>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-bind"/>6.4. @Bind</h2>
                     </div>
                  </div>
               </div>
               <p>
         To create a binding to an advice method from an aspect class, you annotate
         the advice method with
         <code class="literal">@Bind</code>. To create a binding to an
         Interceptor or AspectFactory, you annotate the class itself with
         <code class="literal">@Bind</code>
         since Interceptors only contain one advice (the
         <code class="literal">invoke()</code> method).
         The @Bind annotation will only be recognised in the situations just mentioned.
      </p>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.Bind</code> is:
         </p>
               <pre class="programlisting">
package org.jboss.aop;

@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME)
public @interface Bind
{
  AdviceType type() default AdviceType.AROUND;
  String pointcut();
  String cflow() default "";
}
         </pre>
               <p>
         The
         <code class="literal">@Bind</code> annotation takes three parameters:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">type</code>, valid values are <code class="literal">AdviceType.AROUND</code>,
               <code class="literal">AdviceType.BEFORE</code>, <code class="literal">AdviceType.AFTER</code>,
               <code class="literal">AdviceType.THROWING</code> and <code class="literal">AdviceType.FINALLY</code>.
               See <a href="#advices" title="Chapter 4. Advices">Chapter 4, <i xmlns:xlink="http://www.w3.org/1999/xlink">Advices</i>
                        </a> for a description of the different advice types.
               If omitted, the default is an around advice.
            </li>
                     <li>
                        <code class="literal">pointcut</code>, which is a pointcut expression resolving to the
               joinpoints you want to bind an aspect/interceptor to
            </li>
                     <li>
                        <code class="literal">cflow</code>, which is optional. If defined it must resolve to
               the name of a defined cflow.)
            </li>
                  </ul>
               </div>
               <p>
         
               </p>
               <p>
         
               </p>
               <p>
         In the case of a binding to an advice in an aspect class, the internal name of
         the binding becomes:
         </p>
               <pre class="programlisting">&lt;name of the aspect class&gt;.&lt;the name of the advice method&gt;</pre>
               <p>
         In the case of a binding to an
         <code class="literal">Interceptor</code> or
         <code class="literal">AspectFactory</code>
         implementation, the internal name of the binding becomes:
         </p>
               <pre class="programlisting">&lt;name of the Interceptor/AspectFactory implementation class&gt;</pre>
               <p>
      
               </p>
               <p>
         An example of a binding using an advice method in an aspect class:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.Bind;

   @Aspect (scope = Scope.PER_VM)
   public class MyAspect
   {
      @PointcutDef ("(execution(* org.blah.Foo-&gt;someMethod()) \
            OR execution(* org.blah.Foo-&gt;otherMethod()))")
      public static Pointcut fooMethods;

      @Bind (pointcut="com.mypackage.MyAspect.fooMethods")
      public Object myAdvice(Invocation invocation)
      {
         return invocation.invokeNext();
      }

      @Bind (pointcut="execution("* org.blah.Bar-&gt;someMethod())")
      public Object myAdvice(Invocation invocation)
      {
         return invocation.invokeNext();
      }

   }
         </pre>
               <p>
      
               </p>
               <p>
         
               </p>
         The equivalent using XML configuration would be:
      <pre class="programlisting">
         &lt;aop&gt;
         &lt;aspect class="com.mypackage.MyAspect" scope="PER_VM"/&gt;
         &lt;pointcut
         name="com.mypackage.MyAspect.fooMethods"
         expr="(execution("* org.blah.Foo-&gt;someMethod()) OR \
               execution("* org.blah.Foo-&gt;otherMethod()))"
      /&gt;
         &lt;bind pointcut="com.mypackage.MyAspect.fooMethods"&gt;
         &lt;advice name="myAdvice" aspect="com.mypackage.MyAspect"&gt;
         &lt;/bind&gt;
         &lt;bind pointcut="execution("* org.blah.Bar-&gt;someMethod())"&gt;
         &lt;advice name="otherAdvice" aspect="com.mypackage.MyAspect"&gt;
         &lt;/bind&gt;
         &lt;/aop&gt;
      </pre>
               <p>
         Revisiting the examples above in the @InterceptorDef section, now that
         we know what @Bind means, the equivalent using XML configuration would be:
         </p>
               <pre class="programlisting">
            &lt;aop&gt;
            &lt;interceptor class="com.mypackage.MyInterceptor" scope="PER_VM"/&gt;
            &lt;interceptor factory="com.mypackage.MyInterceptorFactory" scope="PER_VM"/&gt;

            &lt;bind pointcut="execution("* com.blah.Test-&gt;test2(..)"&gt;
            &lt;interceptor-ref name="com.mypackage.MyInterceptor"/&gt;
            &lt;/bind&gt;
            &lt;bind pointcut="execution("* com.blah.Test-&gt;test2(..)"&gt;
            &lt;interceptor-ref name="com.mypackage.MyInterceptorFactory"/&gt;
            &lt;/bind&gt;
            &lt;/aop&gt;
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-introduction"/>6.5. @Introduction</h2>
                     </div>
                  </div>
               </div>
               <p>
         Interface introductions can be done using the
         <code class="literal">@Introduction</code> annotation.
         Only fields within a class annotated with
         <code class="literal">@Aspect</code> or
         <code class="literal">@InterceptorDef</code> can be annotated with
         <code class="literal">@Introduction</code>.
      </p>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.Introduction</code>:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
   public @interface Introduction
   {
      Class target() default java.lang.Class.class;
      String typeExpression() default "";
      Class[] interfaces();
   }
         </pre>
               <p>
         The parameters of
         <code class="literal">@Introduction</code> are:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">target</code>, the name of the class we want to introduce
               an interface to.
            </li>
                     <li>
                        <code class="literal">typeExpression</code>, a type expression that should resolve
               to one or more classes we want to introduce an interface to.
            </li>
                     <li>
                        <code class="literal">interfaces</code>, an array of the interfaces we want to introduce
            </li>
                  </ul>
               </div>
               <p>

         
                  <code class="literal">target</code> or
         <code class="literal">typeExpression</code> has to be specified,
         but not both.
      </p>
               <a id="introductionEx"/>
               <p>
         This is how to use this annotation:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.Introduction;

   @Aspect (scope = Scope.PER_VM)
   public class IntroAspect
   {
      @Introduction (target=com.blah.SomeClass.class, \
            interfaces={java.io.Serializable.class})
      public static Object pojoNoInterfacesIntro;
   }
         </pre>
               <p>
      
               </p>
               <p>
         This means make
         <code class="literal">com.blah.SomeClass.class</code> implement the
         <code class="literal">java.io.Serializable</code> interface. The equivalent configured
         via XML would be:
         </p>
               <pre class="programlisting">
            &lt;introduction class="com.blah.SomeClass.class"&gt;
            &lt;interfaces&gt;
         java.io.Serializable
            &lt;/interfaces&gt;
            &lt;/introduction&gt;
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-mixin"/>6.6. @Mixin</h2>
                     </div>
                  </div>
               </div>
               <p>
         Sometimes when we want to introduce/force a new class to implement an interface,
         that interface introduces new methods to a class. The class needs to implement
         these methods to be valid. In these cases a mixin class is used. The mixin class
         must implement the methods specified by the interface(s) and the main class can
         then implement these methods and delegate to the mixin class.
      </p>
               <p>
         Mixins are created using the @Mixin annotation.  Only methods within a class
         annotated with
         <code class="literal">@Aspect</code> or
         <code class="literal">@InterceptorDef</code>
         can be annotated with
         <code class="literal">@Mixin</code>. The annotated method has
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>be public</li>
                     <li>be static</li>
                     <li>have an empty parameter list, or receive the target of introduction as parameter</li>
                     <li>contain the logic to create the mixin class</li>
                     <li>return an instance of the mixin class</li>
                  </ul>
               </div>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.Mixin</code>:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME)
   public @interface Mixin
   {
      Class target() default java.lang.Class.class;
      String typeExpression() default "";
      Class[] interfaces();
      boolean isTransient() default true;
   }
         </pre>
               <p>
         The parameters of
         <code class="literal">@Mixin</code> are:

         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">target</code>, the name of the class we want to introduce
               an interface to.
            </li>
                     <li>
                        <code class="literal">typeExpression</code>, a type expression that should resolve
               to one or more classes we want to introduce an interface to.
            </li>
                     <li>
                        <code class="literal">interfaces</code>, an array of the interfaces we want to introduce,
               implemented by the mixin class.
            </li>
                     <li>
                        <code class="literal">isTransient</code>. Internally AOP makes the main class keep a
               reference to the mixin class, and this sets if that reference should be
               transient or not. The default is true.
            </li>
                  </ul>
               </div>
               <p>
         
                  <code class="literal">target</code> or
         <code class="literal">typeExpression</code> has to be specified,
         but not both.
      </p>
               <p>
         An example aspect using
         <code class="literal">@Mixin</code> follows:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.Mixin;
   import com.mypackage.POJO;

   @Aspect (scope=org.jboss.aop.advice.Scope.PER_VM)
   public class IntroductionAspect
   {
      @Mixin (target=com.mypackage.POJO.class, interfaces={java.io.Externalizable.class})
      public static ExternalizableMixin createExternalizableMixin(POJO pojo) {
          return new ExternalizableMixin(pojo);
      }
   }
         </pre>
               <p>
      
               </p>
               <p>
         Since this is slightly more complex than the previous examples we have seen, the
         <code class="literal">POJO</code> and
         <code class="literal">ExternalizableMixin</code> classes are
         included here.
      </p>
               <pre class="programlisting">
   package com.mypackage;

   public class POJO
   {
      String stuff;
   }
      </pre>
               <pre class="programlisting">
   package com.mypackage;

   import java.io.Externalizable;
   import java.io.IOException;
   import java.io.ObjectInput;
   import java.io.ObjectOutput;

   public class ExternalizableMixin implements Externalizable
   {
      POJO pojo;

      public ExternalizableMixin(POJO pojo)
      {
         this.pojo = pojo;
      }

      public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
      {
         pojo.stuff = in.readUTF();
      }

      public void writeExternal(ObjectOutput out) throws IOException
      {
         out.writeUTF(pojo.stuff);
      }
   }
      </pre>
               <p>
         This has the same effect as the following XML configuration:
         </p>
               <pre class="programlisting">
            &lt;introduction classs="com.mypackage.POJO"&gt;
            &lt;mixin transient="true"&gt;
            &lt;interfaces&gt;
              java.io.Externalizable
            &lt;/interfaces&gt;
            &lt;class&gt;com.mypackage.ExternalizableMixin&lt;/class&gt;
            &lt;construction&gt;IntroductionAspect.createExternalizableMixin(this)&lt;/construction&gt;
            &lt;/mixin&gt;
            &lt;/introduction&gt;
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-prepare"/>6.7. @Prepare</h2>
                     </div>
                  </div>
               </div>
               <p>
         To prepare a joinpoint or a set of joinpoints for DynamicAOP annotate a field
         with
         <code class="literal">@Prepare</code> in a class anotated with
         <code class="literal">@Aspect</code>
         or
         <code class="literal">@InterceptorDef</code>.
      </p>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.Prepare</code> is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.FIELD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME)
         public @interface Prepare {
       String value() default "";
   }
         </pre>
               <p>
         The single field
         <code class="literal">value</code> contains a pointcut expression
         matching one or more joinpoints.
      </p>
               <p>
         To use
         <code class="literal">@Prepare</code> follow this example:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.Prepare;

   @InterceptorDef (scope = Scope.PER_VM)
   @Bind (pointcut="execution("* com.blah.Test-&gt;test(..)")
   public class MyInterceptor2 implements Interceptor
   {
      @Prepare ("all(com.blah.DynamicPOJO)")
      public static Pointcut dynamicPOJO;

      public Object invoke(Invocation invocation)throws Throwable
      {
         return invocation.invokeNext();
      }
   }

         </pre>
               <p>
      
               </p>
               <p>
         Using XML configuration instead we would write:
         </p>
               <pre class="programlisting">
            &lt;prepare expr="all(com.blah.DynamicPOJO)"/&gt;
         </pre>
               <p>
      
               </p>
               <p>
         This simple example used an
         <code class="literal">@InterceptorDef</code> class for a bit of
         variety in the examples, and to reiterate that
         <code class="literal">@Pointcut</code>,
         <code class="literal">@Introduction</code>,
         <code class="literal">@Mixin</code>,
         <code class="literal">@Prepare</code>,
         <code class="literal">@Typedef</code>,
         <code class="literal">@CFlow</code>,
         <code class="literal">@DynamicCFlow</code> and
         <code class="literal">@AnnotationIntroductionDef</code>
         can all be used both in
         <code class="literal">@InterceptorDef</code> annotated classes AND
         <code class="literal">@Aspect</code> annotated classes. Same for
         <code class="literal">@Bind</code>,
         but that is a special case as mentioned above.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="annotated-prepare-pojo"/>6.7.1. @Prepare POJO</h3>
                        </div>
                     </div>
                  </div>
                  <p>
           You can also annotate a POJO with @Prepare directly in cases where
           you are using Dynamic AOP, and the exact bindings are not known at
           instrumentation time. In this case you annotate the class itself.
           Here's how it is done:
           </p>
                  <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.Prepare;

   @Prepare ("all(this)")
   public class MyDynamicPOJO implements Interceptor
   {
      ...
   }
           </pre>
                  <p>
           
                     <code class="literal">all(this)</code> means the same as
           <code class="literal">all(com.blah.MyDynamicPOJO)</code>, but the use of
           <code class="literal">all(this)</code> is recommended.
        </p>
                  <p>
           The examples just given equate to this XML
           </p>
                  <pre class="programlisting">
            &lt;prepare expr="all(com.blah.MyDynamicPOJO)"/&gt;
           </pre>
                  <p>
        
                  </p>
               </div>
               <p>
        To summarise, when using @Prepare within an @Interceptor or @Aspect
        annotated class, you annotate a field within that class. When using
        @Prepare with a POJO you annotate the class itself.
     </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-typedef"/>6.8. @TypeDef</h2>
                     </div>
                  </div>
               </div>
               <p>
         To use a typedef, you annotate a field with
         <code class="literal">@TypeDef</code>
         in a class anotated with
         <code class="literal">@Aspect</code> or
         <code class="literal">@InterceptorDef</code>.
      </p>
               <p>
         The declaration of
         <code class="literal">org.jboss.aop.TypeDef</code>:
         </p>
               <pre class="programlisting">
package org.jboss.aop;

@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
public @interface TypeDef {
    String value();
}
         </pre>
               <p>
         The single
         <code class="literal">value</code> field takes a type expression that
         resolves to one or more classes. The name of the typedef used for reference
         and internally is:
         </p>
               <pre class="programlisting">&lt;name of @Aspect/@InterceptorDef annotated class&gt;.&lt;name of @TypeDef annotated field&gt;</pre>
               <p>
      
               </p>
               <p>
         Here's how to use it:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.TypeDef;
   import org.jboss.aop.pointcut.Typedef;
   @Aspect (scope=org.jboss.aop.advice.Scope.PER_VM)
   public class TypedefAspect
   {
      @TypeDef ("class(com.blah.POJO)")
      public static Typedef myTypedef;

       @Bind (pointcut="execution(* \
             $typedef{com.mypackage.TypedefAspect.myTypedef}-&gt;methodWithTypedef())")
       public Object typedefAdvice(Invocation invocation) throws Throwable
      {
         return invocation.invokeNext();
      }
   }
         </pre>
               <p>
      
               </p>
               <p>
         The equivalent using XML configuration would be:
         </p>
               <pre class="programlisting">
            &lt;aop&gt;
            &lt;aspect class="com.mypackage.TypedefAspect" scope="PER&gt;VM"/&gt;
            &lt;typedef name="com.mypackage.TypedefAspect.myTypedef" expr="class(com.blah.POJO)"/&gt;
            &lt;bind
         pointcut="execution(* \
            $typedef{com.mypackage.TypedefAspect.myTypedef}-&gt;methodWithTypedef())"
            &gt;
            &lt;advice name="typedefAdvice" aspect="com.mypackage.TypedefAspect"/&gt;
            &lt;/bind&gt;
            &lt;/aop&gt;
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-cflow"/>6.9. @CFlowDef</h2>
                     </div>
                  </div>
               </div>
               <p>
         To create a CFlow stack, you annotate a field with
         <code class="literal">@CFlowDef</code>
         in a class anotated with
         <code class="literal">@Aspect</code> or
         <code class="literal">@InterceptorDef</code>.
         The declaration of
         <code class="literal">org.jboss.aop.CFlowStackDef</code> is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
         public @interface CFlowStackDef
   {
      CFlowDef[] cflows();
   }
         </pre>
               <p>
         In turn the declaration of
         <code class="literal">org.jboss.aop.CFlowDef</code> is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   public @interface CFlowDef {
       boolean called();
       String expr();
   }
         </pre>
               <p>
         The parameters of
         <code class="literal">@CFlowDef</code> are:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">called</code>, whether the corresponding expr should appear
               in the stack trace or not.
            </li>
                     <li>
                        <code class="literal">expr</code>, a string matching stack a trace element
            </li>
                  </ul>
               </div>
               <p>
         The name of the CFlowStackDef used for reference and internally is:
         </p>
               <pre class="programlisting">&lt;name of @Aspect/@InterceptorDef annotated class&gt;.&lt;name of @CFlowStackDef annotated field&gt;</pre>
               <p>
      
               </p>
               <p>
         CFlowStackDef is used like the following example:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.CFlowStackDef;
   import org.jboss.aop.pointcut.CFlowStack;

   @Aspect (scope=org.jboss.aop.advice.Scope.PER_VM)
   public class CFlowAspect
   {

      @CFlowStackDef (cflows={@CFlowDef(expr= "void com.blah.POJO-&gt;cflowMethod1()", \
            called=false),  @CFlowDef(expr = "void com.blah.POJO-&gt;cflowMethod2()", \
            called=true)})
      public static CFlowStack cfNot1And2Stack;

      @Bind (pointcut="execution(void com.blah.POJO*-&gt;privMethod())", \
            cflow="com.mypackage.CFlowAspect.cfNot1And2Stack")
      public Object cflowAdvice(Invocation invocation) throws Throwable
      {
         return invocation.invokeNext();
      }
   }
         </pre>
               <p>
      
               </p>
               <p>
         The above means the same as this XML:
         </p>
               <pre class="programlisting">
            &lt;aop&gt;
            &lt;cflow-stack name="com.mypackage.CFlowAspect.cfNot1And2Stack"&gt;
            &lt;called expr="void com.blah.POJO-&gt;cflowMethod1()"/&gt;
            &lt;not-called expr="void com.blah.POJO-&gt;cflowMethod2()"/&gt;
            &lt;/cflow-stack&gt;
            &lt;/aop&gt;
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-dynamiccflow"/>6.10. @DynamicCFlowDef</h2>
                     </div>
                  </div>
               </div>
               <p>
         To create a dynamic CFlow you annotate a class implementing
         <code class="literal">org.jboss.aop.pointcut.DynamicCFlow</code> with
         <code class="literal">@DynamicCFlowDef</code>. The declaration of
         <code class="literal">@org.jboss.aop.DynamicCFlowDef</code> is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
   public @interface DynamicCFlowDef
   {
   }
         </pre>
               <p>
      
               </p>
               <p>
         Here is a @DynamicCFlow annotated class:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.DynamicCFlowDef;
   import org.jboss.aop.pointcut.DynamicCFlow;

   @DynamicCFlowDef
   public class MyDynamicCFlow implements DynamicCFlow
   {
      public static boolean execute = false;

      public boolean shouldExecute(Invocation invocation)
      {
         return execute;
      }
   }
         </pre>
               <p>
      
               </p>
               <p>
         The name of the
         <code class="literal">@DynamicCFlowDef</code> annotated class gets used as
         the name of the cflow for references.
      </p>
               <p>
         To use the dynamic cflow we just defined:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   @Aspect (scope=org.jboss.aop.advice.Scope.PER_VM)
   public class CFlowAspect
   {
      @Bind (pointcut="execution(void com.blah.POJO-&gt;someMethod())", \
            cflow="com.mypackage.MyDynamicCFlow")
      public Object cflowAdvice(Invocation invocation) throws Throwable
      {
         return invocation.invokeNext();
      }
   }
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-annotationintro"/>6.11. @AnnotationIntroductionDef</h2>
                     </div>
                  </div>
               </div>
               <p>
         You can introduce annotations by annotating a field with the
         <code class="literal">@AnnotationIntroductionDef</code> in a class anotated with
         <code class="literal">@Aspect</code> or
         <code class="literal">@InterceptorDef</code>.
         The declaration of
         <code class="literal">org.jboss.aop.AnnotationIntroductionDef</code> is:
         </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target (ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME)
         public @interface AnnotationIntroductionDef
   {
      String expr();
      boolean invisible();
      String annotation();
   }
         </pre>
               <p>
         The parameters of
         <code class="literal">@AnnotationIntroductionDef</code> are:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">expr</code>, pointcut matching the classes/constructors/methods/fields
               we want to annotate.
            </li>
                     <li>
                        <code class="literal">invisible</code>, if true: the annotation's retention is RetentionPolicy.CLASS;
               false: RetentionPolicy.RUNTIME
            </li>
                     <li>
                        <code class="literal">annotation</code>, the annotation we want to introduce.
            </li>
                  </ul>
               </div>
               <p>

      
               </p>
               <p>
         The listings below make use of an annotation called
         <code class="literal">@com.mypackage.MyAnnotation</code>:
         </p>
               <pre class="programlisting">
   package com.mypackage;
   public interface MyAnnotation
   {
      String string();
      int integer();
      boolean bool();
   }
         </pre>
               <p>
         What its parameters mean is not very important for our purpose.
      </p>
               <a id="annotatIntroductEx"/>
               <p>
         The use of
         <code class="literal">@AnnotationIntroductionDef</code>:
         </p>
               <pre class="programlisting">
   package com.mypackage;

   import org.jboss.aop.AnnotationIntroductionDef:
   import org.jboss.aop.introduction.AnnotationIntroduction;

   @.InterceptorDef (scope=org.jboss.aop.advice.Scope.PER_VM)
   @org.jboss.aop.Bind (pointcut="all(com.blah.SomePOJO)")
   public class IntroducedAnnotationInterceptor implements Interceptor
   {
      @org.jboss.aop.AnnotationIntroductionDef \
            (expr="method(* com.blah.SomePOJO-&gt;annotationIntroductionMethod())", \
             invisible=false, \
             annotation="@com.mypackage.MyAnnotation \
                (string='hello', integer=5, bool=true)")
      public static AnnotationIntroduction annotationIntroduction;

      public String getName()
      {
         return "IntroducedAnnotationInterceptor";
      }

      public Object invoke(Invocation invocation) throws Throwable
      {
         return invocation.invokeNext();
      }
   }
         </pre>
               <p>
         Note that the reference to
         <code class="literal">@com.mypackage.MyAnnotation</code> must use the
         fully qualified class name, and that the value for its string parameter uses single quotes.
      </p>
               <p>
         The previous listings are the same as this XML configuration:
         </p>
               <pre class="programlisting">
            &lt;annotation-introduction
      expr="method(* com.blah.SomePOJO-&gt;annotationIntroductionMethod())
      invisible="false"
            &gt;
      @com.mypackage.MyAnnotation (string="hello", integer=5, bool=true)
            &lt;/annotation-introduction&gt;
         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-precedence"/>6.12. @Precedence</h2>
                     </div>
                  </div>
               </div>
               <p>You can declare precedence by annotating a class with <code class="literal">@Precedence</code>, and then annotate
      fields where the types are the various Interfaces/Aspects you want to sort. You annotate fields where the
      type is an interceptor with <code class="literal">@PrecedenceInterceptor</code>. When the type is an
      aspect class, you annotate the field with <code class="literal">@PrecedenceAdvice</code>. The definitions
      of org.jboss.aop.Precedence, org.jboss.aop.PrecedenceInterceptor and
      org.jboss.aop.PrecedenceAdvice are
      </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME)
   public @interface Precedence
   {
   }
      </pre>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
   public @interface PrecedenceInterceptor
   {
   }
      </pre>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
   public @interface PrecedenceAdvice
   {
      String value();
   }
      </pre>
               <p>
         The <code class="literal">value()</code> attribute of <code class="literal">PrecedenceAdvice</code> is the name of the
         advice method to use.
      </p>
               <p>
         The example shown below declares a relative sort order where <code class="literal">org.acme.Interceptor</code>
         must always be invoked before <code class="literal">org.acme.Aspect.advice1()</code> which must be invoked before
         <code class="literal">org.acme.Aspect.advice2()</code>:
      </p>
               <pre class="programlisting">
   import org.jboss.aop.Precedence;
   import org.jboss.aop.PrecedenceAdvice;

   @Precedence
   public class MyPrecedence
   {
      @PrecedenceInterceptor
      org.acme.Interceptor intercept;

      @PrecedenceAdvice ("advice1")
      org.acme.Aspect precAdvice1;

      @PrecedenceAdvice ("advice2")
      org.acme.Aspect precAdvice2;
   }
      </pre>
               <p>
         The ordering of interceptors/advices defined via annotations that have no precedence defined, is arbitrary.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="annotated-declare"/>6.13. @DeclareError and @DeclareWarning</h2>
                     </div>
                  </div>
               </div>
               <p>
         You can declare checks to be enforced at instrumentation time. They take a pointcut and a message.
         If the pointcut is matched, the message is printed out. To use this with annotations, annotate fields
         with <code class="literal">DeclareWarning</code> or <code class="literal">DeclareError</code> within a class annotated with
         <code class="literal">@Aspect</code> or <code class="literal">@InterceptorDef</code>. The definitions of
         <code class="literal">org.jboss.aop.DeclareError</code> and <code class="literal">org.jboss.aop.DeclareWarning</code> are:
      </p>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
   public @interface DeclareWarning
   {
      String expr();
      String msg();
   }
      </pre>
               <pre class="programlisting">
   package org.jboss.aop;

   @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME)
   public @interface DeclareError
   {
      String expr();
      String msg();
   }
      </pre>
               <p>
         For both: the expr() attribute is a pointcut expression that should not occur, and the msg() attribute is
         the message to print out if a match is found for the pointcut. If you use
         <code class="literal">DeclareWarning</code> instrumentation/your application will simply continue having printed the
         message you supplied. In the case of <code class="literal">DeclareError</code>, the message is logged and an error is
         thrown, causing instrumentation/your application to stop. Here is an example:
      </p>
               <pre class="programlisting">
   import org.jboss.aop.Aspect;
   import org.jboss.aop.pointcut.Pointcut;
   import org.jboss.aop.DeclareError;
   import org.jboss.aop.DeclareWarning;

   @Aspect (scope=org.jboss.aop.advice.Scope.PER_VM)
   public class DeclareAspect
   {
      @DeclareWarning (expr="class($instanceof{VehicleDAO}) AND \
         !has(public void *-&gt;save())", \
         msg="All VehicleDAO subclasses must override the save() method.")
      Pointcut warning;

      @DeclareError (expr="call(* org.acme.businesslayer.*-&gt;*(..)) \
         AND within(org.acme.datalayer.*)", \
         msg="Data layer classes should not call up to the business layer")
      Pointcut error;
   }
      </pre>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="dynamic"/>Chapter 7. Dynamic AOP</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#dyn-1">7.1. Hot Deployment</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#dyn-2">7.2. Per Instance AOP</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#dyn-3">7.3. Preparation</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#dyn-4">7.4. Improved Instance API</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#dyn-5">7.5. DynamicAOP with HotSwap</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="dyn-1"/>7.1. Hot Deployment</h2>
                     </div>
                  </div>
               </div>
               <p>
         With JBoss AOP you can change advice and interceptor bindings at runtime.  You can unregister
         existing bindings, and hot deploy new bindings if the given joinpoints have been instrumented.

         Hot-deploying within the JBoss application server is as easy as putting (or removing) a
         <code class="literal">*-aop.xml</code>
         file or
         <code class="literal">.aop</code> jar file within the deploy/ directory.

         There is also a runtime API for adding advice bindings at runtime.  Getting an instance of
         <code class="literal">org.jboss.aop.AspectManager.instance()</code>, you can add your binding.
      </p>
               <pre class="programlisting">      org.jboss.aop.advice.AdviceBinding binding = 
                              new AdviceBinding("execution(POJO-&gt;new(..))", null);
      binding.addInterceptor(SimpleInterceptor.class);
      AspectManager.instance().addBinding(binding);</pre>
               <p>
         First, you allocated an
         <code class="literal">AdviceBinding</code> passing in a pointcut expression.  Then you add
         the interceptor via its class and then add the binding through the AspectManager.  When the binding is added
         the AspectManager will iterate through ever loaded class to see if the pointcut expression matches any
         of the joinpoints within those classes.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="dyn-2"/>7.2. Per Instance AOP</h2>
                     </div>
                  </div>
               </div>
               <p>
          Any class that is instrumented by JBoss AOP, is forced to implement the
         <code class="literal">org.jboss.aop.Advised interface.</code>
      
               </p>
               <pre class="programlisting">public interface InstanceAdvised
{
   public InstanceAdvisor _getInstanceAdvisor();
   public void _setInstanceAdvisor(InstanceAdvisor newAdvisor);
}

public interface Advised extends InstanceAdvised
{
   public Advisor _getAdvisor();
}</pre>
               <p>
         The InstanceAdvisor is the interesting interface here.  InstanceAdvisor allows you to insert Interceptors
         at the beginning or the end of the class's advice chain.
      </p>
               <pre class="programlisting">public interface InstanceAdvisor
{
   public void insertInterceptor(Interceptor interceptor);
   public void removeInterceptor(String name);
   public void appendInterceptor(Interceptor interceptor);

   public void insertInterceptorStack(String stackName);
   public void removeInterceptorStack(String name);
   public void appendInterceptorStack(String stackName);

   public SimpleMetaData getMetaData();

}</pre>
               <p>
         So, there are three advice chains that get executed consecutively in the same java call stack.  Those
         interceptors that are added with the
         <code class="literal">insertInterceptor()</code> method for the given object
         instance are executed first.  Next, those advices/interceptors that were bound using regular
         <code class="literal">bind</code>s.  Finally, those interceptors added with the
         <code class="literal">appendInterceptor()</code> method to the object
         instance are executed.  You can also reference
         <code class="literal">stack</code>s and insert/append full stacks
         into the pre/post chains.
      </p>
               <p>
         Besides interceptors, you can also append untyped metadata to the object instance via the getMetaData() method.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="dyn-3"/>7.3. Preparation</h2>
                     </div>
                  </div>
               </div>
               <p>
         Dynamic AOP cannot be used unless the particular joinpoint has been instrumented.  You can force intrumentation
         with the
         <code class="literal">prepare</code> functionality
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="dyn-4"/>7.4. Improved Instance API</h2>
                     </div>
                  </div>
               </div>
               <p>
         As mentioned, you can add more aspects to a woven class using the 
         <code class="literal">org.jboss.aop.InstanceAdvisor</code>. This API is limited to adding
         interceptors to the existing intereptor chains, so it is a bit limited.
      </p>
               <p>
         The new default weaving mode introduced in JBoss AOP 2.0.0 still allows you access to the 
         <code class="literal">InstanceAdvisor</code> interface, but also offers a fuller instance API, which allows you to add bindings,
         annotation overrides etc. via the normal dynamic AOP API. This is underdocumented,
         but for a full overview of the capabilites take a look at how 
         <code class="literal">org.jboss.aop.AspectXmlLoader</code> interacts with 
         <code class="literal">org.jboss.aop.AspectManager</code>. We are working on a new tidier API for 
         the next version of JBoss AOP. Normally, for dynamic AOP you add 
         things to the top level <code class="literal">AspectManager</code>, which means that all instances
         of all woven classes can be affected.
      </p>
               <p>
         In JBoss AOP 2.0.0, each aspectized class has its own Domain. A domain is a sub-AspectManager. 
         What is deployed in the main AspectManager is visible to the class's domain, but not vice versa. 
         Furthermore each advised instance has its own Domain again which is a child of the class's domain. 
         The Domain class is a sub-class of the AspectManager, meaning you can add ANYTHING supported by 
         JBoss AOP to it, you are not limited to just interceptors. In the following example we prepare
         all joinpoints of the POJO class and declare an aspect called <code class="literal">MyAspect</code>
      
               </p>
               <pre class="programlisting">
   &lt;!-- Weave in the hooks into our POJO class and add the interceptors --&gt;
   &lt;aop&gt;
      &lt;aspect class="MyAspect"/&gt;
      &lt;prepare expr="all(POJO)"/&gt;
   &lt;/aop&gt;
   
         </pre>
               <pre class="programlisting">
   POJO pojo1 = new POJO();
   POJO pojo2 = new POJO();
   
      </pre>
               <pre class="programlisting">
   pojo1.someMethod();
   
      </pre>
               <p>
         At this stage, our <code class="literal">POJO</code> has the hooks woven in for AOP, but now bindings are deployed, so our call 
         to <code class="literal">POJO.someMethod()</code> is not intercepted. Next let us add a binding to <code class="literal">POJO</code>'s class domain.
      </p>
               <pre class="programlisting">
   //All woven classes implement the Advised interface
   Advised classAdvisor = ((Advised)pojo1);
   //Get the domain used by all instances of POJO
   AspectManager pojoDomain = classAdvisor._getAdvisor().getManager();
   //Add a binding with an aspect for that class this is similar to
   AdviceBinding binding1 = new AdviceBinding("execution(* POJO-&gt;someMethod*(..))", null);
   AspectDefinition myAspect = AspectManager.instance().getAspectDefinition("MyAspect");
   binding1.addInterceptorFactory(new AdviceFactory(myAspect, "intercept"));

   //Add the binding to POJO's domain
   pojoDomain.addBinding(binding1);

   pojo1.someMethod();
   pojo2.someMethod();
      
      </pre>
               <p>
         Now we have added a binding to <code class="literal">POJO</code>'s class Domain. Both calls to 
         <code class="literal">someMethod()</code> get intercepted by MyAspect
      </p>
               <pre class="programlisting">
   //Create an annotation introduction
   AnnotationIntroduction intro = AnnotationIntroduction.createMethodAnnotationIntroduction(
         "* POJO-&gt;someMethod()",
         "@MyAnnotation",
         true);

   //Create another binding
   AdviceBinding binding2 = new AdviceBinding("execution(* POJO-&gt;@MyAnnotation)", null);
   binding2.addInterceptor(MyInterceptor.class);

   //All woven instances have an instance advisor
   InstanceAdvisor instanceAdvisor1 = ((Advised)pojo1)._getInstanceAdvisor();

   //The instance advisor has its own domain
   Domain pojo1Domain = instanceAdvisor1.getDomain();

   //Add the annotation override and binding to the domain
   pojo1Domain.addAnnotationOverride(intro);
   pojo1Domain.addBinding(binding2);

   pojo1.someMethod();
   pojo2.someMethod();
   
      </pre>
               <p>
         We have added an annotation override and a new binding matching on that annotaton to <code class="literal">pojo1</code>'s domain, so 
         when calling <code class="literal">pojo1.someMethod()</code> this gets intercecpted by <code class="literal">MyAspect</code>
         AND <code class="literal">MyInterceptor</code>. <code class="literal">pojo2.someMethod()</code> still gets intercepted by MyAspect only.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="dyn-5"/>7.5. DynamicAOP with HotSwap</h2>
                     </div>
                  </div>
               </div>
               <p>
			When running JBoss AOP with HotSwap, the dynamic AOP operations may result in the weaving of
         bytecodes. In this case, the flow control of joinpoints matched only by <code class="literal">prepare</code>
         expressions is not affected before any advices or interceptors are applied to them
         via dynamic aop. Only then, the joinpoint bytecodes will be weaved to start invoking the added 
         advices and interceptors and, as a result, their flow control will be affected.
      </p>
               <p>
         On the other hand, if HotSwap is disabled, the joinpoints matched by <code class="literal">prepare</code>
         expressions are completely instrumented and the flow control is affected before classes get loaded, even
         if no interceptors are applied to them with dynamic aop.
      </p>
               <p>
         To learn how to enable HotSwap, refer to the "Running Aspectized Application" chapter.
      </p>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="installing"/>Chapter 8. Installing</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#installing-standalone">8.1. Installing Standalone</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#installing-jboss40-jdk50">8.2. Installing with JBoss 4.0.x and JBoss 4.2.x Application Server for JDK 5</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#installing-jboss5-jdk5">8.3. Installing with JBoss Application Server 5</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <p>
         This section defines how to install JBoss AOP standalone, within JBoss 4.0.x, JBoss 4.2.x and within JBoss 5.x
   </p>
            <div class="mediaobject" align="center">
               <img src="../shared/images/install.jpg" align="middle"/>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="installing-standalone"/>8.1. Installing Standalone</h2>
                     </div>
                  </div>
               </div>
               <p>
         There's nothing really to install if you're running outside the JBoss application server. Just use the libraries under <code class="literal">lib/</code>.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="installing-jboss40-jdk50"/>8.2. Installing with JBoss 4.0.x and JBoss 4.2.x Application Server for JDK 5</h2>
                     </div>
                  </div>
               </div>
               <p>
         DISCLAIMER: We no longer actively test against JBoss Application Server 4.0.x or 4.2.x. If there are any
         problems with the issues outlined below, please contact us on the JBoss AOP user forum at http://www.jboss.org.
      </p>
               <p>
         To install JBoss AOP in JBoss 4.0.x or JBoss 4.2.x Application Server: with JDK 5, there is an ant build script to
         install into the application server. It lives in <code class="literal">jboss-40-install/jboss-aop-jdk50.deployer/build.xml</code>.
         Modify <code class="literal">jboss-40-install/jboss-aop-jdk50.deployer/jboss.properties</code>  to point to the the root of your
         JBoss installation and specify the application server configuration you want to upgrade. These are the steps taken by
         the ant script:
      </p>
               <div class="orderedlist">
                  <ol>
                     <li>
             Back up the existing 
            <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer</code> to
            <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer.bak</code>
                     </li>
                     <li>
             Copy the files from <code class="literal">jboss-40-install/jboss-aop-jdk50.deployer</code> over the files that already
             exist in your existing JBoss Application Server distribution under
            <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer</code>
                     </li>
                     <li>
            In JBoss 4.0.4.GA and later, move <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer/javassist.jar</code>
            to <code class="literal">${jboss.home}/server/&lt;config-name&gt;/lib/javassist.jar</code>. Any existing javassist.jar in that location is copied to
            <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer.bak/lib/javassist.bak</code>
                     </li>
                     <li>
            If you NOT upgrading from a previous AOP 2 distribution, open up
            <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer/jboss-aspect-library-jdk50.jar</code> and
            delete all classes and subpackages under <code class="literal">org.jboss.aop</code>. In AOP 2.0 we changed the packaging, these
            classes now exist inside <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer/jboss-aop-as4-deployer.jar</code>. 
            Also, we delete any files that also exist in 
            <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deploy/jboss-aop-jdk50.deployer/jboss-standalone-aspect-library.jar</code>
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="installing-jboss5-jdk5"/>8.3. Installing with JBoss Application Server 5</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AS 5 ships with AOP 2.0.0.GA. To upgrade to a newer AOP version, we have provided am an script to 
         upgrade the server. It can be found at <code class="literal">jboss-50-install/build.xml</code>. Modifly 
         <code class="literal">jboss-50-install</code> to point to the root of your JBoss installation, and specify the
         application server configuration you want to upgrade. These are the steps taken by the
         ant script:
      </p>
               <div class="orderedlist">
                  <ol>
                     <li>
             Back up the existing <code class="literal">${jboss.home}/lib</code> and 
             <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deployers/jboss-aop-jboss5.deployer</code> folders.
         </li>
                     <li>
             Overwrite the <code class="literal">${jboss.home}/server/&lt;config-name&gt;/deployers/jboss-aop-jboss5.deployer</code> 
             folder with the files from <code class="literal">jboss-50-install/jboss-aop-jboss5.deployer</code>.
         </li>
                     <li>
             Overwrite the <code class="literal">${jboss.home}/lib</code> folder with the files from 
             <code class="literal">jboss-50-install/lib</code>.
         </li>
                  </ol>
               </div>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="compiling"/>Chapter 9. Building and Compiling Aspectized Java</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#modes">9.1. Instrumentation modes</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#ant">9.2. Ant Integration</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#commandline">9.3. Command Line</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="modes"/>9.1. Instrumentation modes</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AOP works by instrumenting the classes you want to run. This means
         that modifications to the bytecode are made in order to add extra information
         to the classes to hook into the AOP library.  JBoss AOP allows for two types
         of instrumentation
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
               Precompiled - The classes are instrumented in a separate aop compilation
               step before they are run.
            </li>
                     <li>
               Loadtime - The classes are instrumented when they are first loaded.
            </li>
                  </ul>
               </div>
               <p>
         This chapter describes the steps you need to take to precompile your classes
         with the aop precompiler.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="ant"/>9.2. Ant Integration</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AOP comes with an ant task that you can use for precompiling your
         classes with the aop precompiler. An example build.xml file is the basis
         for the explanation.
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;project default="compile" name="JBoss/AOP"&gt;
   &lt;target name="prepare"&gt;
         </pre>
               <p>
      
               </p>
               <p>
         Define the source directory, and the directory to compile classes to.
         </p>
               <pre class="programlisting">
         &lt;property name="src.dir" value="PATH TO YOUR SOURCE DIR"&gt;
         &lt;property name="classes.dir" value="PATH TO YOUR DIR FOR COMPILED CLASSES"&gt;
         </pre>
               <p>
      
               </p>
               <p>
         Define also the path of your JBoss AOP installation, as well as the path to
         the lib directory:
         </p>
               <pre class="programlisting">
          &lt;property name="jboss.aop.root" value="PATH TO JBOSS AOP HOME"/&gt;
          &lt;property name="jboss.aop.lib" value="${jboss.aop.root}/lib"/&gt;
         </pre>
               <p>
      
               </p>
               <p>
         Include the jboss-aop.jar and the jars it depends on in the classpath:
         </p>
               <pre class="programlisting">
      &lt;path id="classpath"&gt;
         &lt;pathelement path="${jboss.aop.lib}/jboss-aop.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/javassist.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/trove.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/jboss-common-core.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/jboss-logging-spi.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/jboss-logging-log4j.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/jboss-mdr.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/jboss-reflect.jar"/&gt;
         &lt;pathelement path="${jboss.aop.lib}/log4j.jar"/&gt;
      &lt;/path&gt;
         </pre>
               <p>
      
               </p>
               <p>
         As an alternative, you can use the single jar provided with JBoss AOP. This
         jar bundles all the libraries used by JBoss AOP in a single unit. To use this
         jar, just define:
         </p>
               <pre class="programlisting">
      &lt;path id="classpath"&gt;
         &lt;pathelement path="${jboss.aop.lib}/jboss-aop-single.jar"/&gt;
      &lt;/path&gt;
         </pre>
               <p>
      
               </p>
               <p>
         Now, define the
         <code class="literal">org.jboss.aop.ant.AopC</code> ant aop precompiler task:
         </p>
               <pre class="programlisting">
      &lt;taskdef name="aopc" classname="org.jboss.aop.ant.AopC"
         classpathref="jboss.aop.classpath"/&gt;
      &lt;/target&gt;
         </pre>
               <p>
      
               </p>
               <p>
         
               </p>
               <pre class="programlisting">
   &lt;target name="compile" depends="prepare"&gt;
         </pre>
               <p>
      
               </p>
               <p>
         Compile the files (from the source directory to the compiled classes directory):
         </p>
               <pre class="programlisting">
      &lt;javac srcdir="${src.dir}"
         destdir="${classes.dir}"
         debug="on"
         deprecation="on"
         optimize="off"
         includes="**"&gt;
         &lt;classpath refid="classpath"/&gt;
      &lt;/javac&gt;
         </pre>
               <p>
      
               </p>
               <p>
         Now use the ant aop precompiler task, it reads the files from the classes directory and weaves those classes,
         ovewriting them with the corresponding weaved version.
         </p>
               <pre class="programlisting">
      &lt;aopc compilerclasspathref="classpath" verbose="true"&gt;
         &lt;classpath path="${classes.dir}"/&gt;
         &lt;src path="${classes.dir}"/&gt;
         &lt;include name="**/*.class"/&gt;
         &lt;aoppath path="jboss-aop.xml"/&gt;
         &lt;aopclasspath path="${classes.dir}"/&gt;
      &lt;/aopc&gt;
   &lt;/target&gt;
&lt;/project&gt;
         </pre>
               <p>
      
               </p>
               <p>
         The last tag, <code class="literal">aopclasspath</code>, must be used only if you used annotations to configure aspects, bindings,
         and the like. If this is the case and you are not using a jboss-aop.xml file, you can ommit the <code class="literal">aoppath</code>
         tag. You can also use both annotations and XML to configure aspects. In this case, you must declare both tags.
         The complete list of the parameters that 
         <code class="literal">org.jboss.aop.ant.AopC</code> ant task takes follows:
      </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">compilerclasspath</code> or
            <code class="literal">compilerclasspathref</code> -
               These are interchangable, and represent the jars needed for the aop precompiler
               to work. The
            <code class="literal">compilerclasspath</code> version takes the paths of the
               jar files, and the
            <code class="literal">compilerclasspathref</code> version takes the
               name of a predefined ant path. They can be specified as attributes of
            <code class="literal">aopc</code>, as shown above.
            <code class="literal">compilerclasspath</code> can also be
               specified as a child element of
            <code class="literal">aopc</code>, in which case you can use
               all the normal ant functionality for paths (e.g. fileset).
         </li>
                     <li>
                        <code class="literal">classpath</code> or
            <code class="literal">classpathref</code> - Path to the
               compiled classes to be instrumented. The
            <code class="literal">classpath</code>
               version takes the path of the directory, and the
            <code class="literal">classpathref</code>
               version takes the name of a predefined ant path. They both be specified as attributes
               of
            <code class="literal">aopc</code>.
            <code class="literal">classpath</code> can also be
               specified as a child element of
            <code class="literal">aopc</code>, as shown above, in which case
               you can use all the normal ant functionality for paths (e.g. fileset). The full classpath
               of the underlying java process will be classpath + compilerclasspath.
         </li>
                     <li>
                        <code class="literal">src</code> - A directory containing files to be transformed.  You can use multiple src elements to specify more that one root directory for transformation.
         </li>
                     <li>
                        <code class="literal">include</code> - This is optional and it serves as a filter
            to pick out which files within <code class="literal">src</code> should be transformed. You can use wildcards within the
            <code class="literal">name</code> expression, and you can also use multiple <code class="literal">include</code> elements.
         </li>
                     <li>
                        <code class="literal">verbose</code> - Default is false. If true, verbose output
               is generated, which comes in handy for diagnosing unexpected results.
         </li>
                     <li>
                        <code class="literal">report</code> - Default is false. If true, the classes are not
               instrumented, but a report called
            <code class="literal">aop-report.xml</code> is generated
               which shows all classes that have been loaded that pertain to AOP, what interceptors
               and advices that are attached, and also what metadata that has been attached. One
               particularly useful thing is the unbounded section. It specifys all bindings
               that are not bound. It allows you to debug when you might have a typo in one of your
               XML deployment descriptors.
               <p/>
               Report generation works on the instrumented classes, so to get valid data in your
               report, you have to to make two passes with <code class="literal">aopc</code>. First
               you run <code class="literal">aopc</code> with <code class="literal">report="false"</code> to
               instrument the classes, and then you run <code class="literal">aopc</code> with
               <code class="literal">report="true"</code> to generate the report.
         </li>
                     <li>
                        <code class="literal">aoppath</code> - The path of the
            <code class="literal">*-aop.xml</code> file containing
               the xml configuration of your bindings. Files or Directories can be specified.
            If it is a directory, JBoss AOP will take all
            <code class="literal">aop.xml</code> files from that directory.
               This gets used for the
            <code class="literal">jboss.aop.path</code>
               optional system property which is described in the "Command Line" section. If you have more
               than one xml file, for example if you have both a "normal"
            <code class="literal">jboss-aop.xml</code>
               file, and a
            <pre class="programlisting">
               &lt;aoppath&gt;
               &lt;pathelement path="jboss-aop.xml"/&gt;
               &lt;pathelement path="xmldir"/&gt;
               &lt;/aoppath&gt;
            </pre>
                     </li>
                     <li>
                        <code class="literal">aopclasspath</code> - This should mirror your class path and contain all JARs/directories
               that may have annotated aspects (Ses Chapter "Annotated Bindings").  The AOPC compiler will browse
               each class file in this path to determine if any of them are annotationed with
            <code class="literal">@Aspect</code>.
               This gets used for the
            <code class="literal">jboss.aop.class.path</code>
               optional system property which is described in the "Command Line" section. If you have more
               than one jar file, you can specify these as follows:
            <pre class="programlisting">
               &lt;aopclasspath&gt;
               &lt;pathelement path="aspects.jar"/&gt;
               &lt;pathelement path="foo.jar"/&gt;
               &lt;/aopclasspath&gt;
            </pre>
                     </li>
                     <li>
                        <code class="literal">maxsrc</code> - The ant task expands any directories in
               <code class="literal">src</code> to list all class files, when creating the parameters
               for the java command that actually performs the compilation. On some operating
               systems there is a limit to the length of vaid command lines. The default value
               for <code class="literal">maxsrc</code> is 1000. If the total length of all the files used
               is greater than <code class="literal">maxsrc</code>, a temporary file listing the files
               to be transformed is used and passed in to the java command instead. If you have
               problems running the <code class="literal">aopc</code> task, try setting this value to
               a value smaller than 1000.
          </li>
                  </ul>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="commandline"/>9.3. Command Line</h2>
                     </div>
                  </div>
               </div>
               <p>
            To run the aop precompiler from the command line you need all the aop jars on your classpath, and
            the class files you are instrumenting must have everything they would need to run in the java
            classpath, including themselves, or the precompiler will not be able to run.
      </p>
               <p>
         The
         <code class="literal">jboss.aop.path</code> optional system property points to XML files that contain your
            pointcut, advice bindings, and metadata definitions that the precompiler will use to instrument
            the .class files. The property can have one or files it points to delimited by the operating
            systems specific classpath delimiter (';' on windows, ':' on unix).  Files or Directories can be specified.
            If it is a directory, JBoss AOP will take all
         <code class="literal">aop.xml</code> files from that directory.
      </p>
               <p>
         The
         <code class="literal">jboss.aop.class.path</code> optional system property points to all JARs or directories that
            may have classes that are annotated as
         <code class="literal">@Aspect</code> (See Chapter "Annotated Bindings").
            JBoss AOP will browse all classes in this path to see if they are annotated.
            The property can have one or files it points to delimited by the operating
            systems specific classpath delimiter (';' on windows, ':' on unix). 
      </p>
               <p>
            It is invoked as:
         </p>
               <pre class="programlisting">
$java -classpath ... [-Djboss.aop.path=...] [-Djboss.aop.class.path=...] \
                     org.jboss.aop.standalone.Compiler &lt;class files or directories&gt;
         </pre>
               <p>
      
               </p>
               <p>
         In the /bin folder of the distribution we have provided batch/script files to make
         this easier. It includes all the aop libs for you, so you just have to worry
         about your files. The usage:
         </p>
               <pre class="programlisting">
$ aopc &lt;classpath&gt; [-aoppath ...] [-aopclasspath ...] [-report] [-verbose] \
      &lt;class files or directories&gt;+
         </pre>
               <p>
      
               </p>
               <p>
         
               </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">classpath</code> - path to your classes and any jars your code depends on
            </li>
                  </ul>
               </div>
               <p>
         The other parameters are the same as above.
      </p>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="running"/>Chapter 10. Running Aspectized Applications</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#d0e4263">10.1. Loadtime, Compiletime and HotSwap Modes</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#standalone">10.2. Regular Java Applications</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#standalone-compiletime">10.2.1. Precompiled instrumentation</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4355">10.2.2. Loadtime</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4502">10.2.3. HotSwap</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4548">10.2.4. User-Defined ClassLoaders</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#jboss">10.3. JBoss Application Server</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4567">10.3.1. Packaging AOP Applications</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4603">10.3.2. The JBoss AspectManager Service</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#running-as-sun-jdk">10.3.3. Loadtime transformation in JBoss AS Using Sun JDK</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4699">10.3.4. JBoss 5 and JRockit</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4752">10.3.5. Improving Loadtime Performance in a JBoss AS Environment</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#d0e4757">10.4. Scoping aop to the classloader</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4762">10.4.1. Deploying as part of a scoped classloader</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#d0e4767">10.4.2. Attaching to a scoped deployment</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
               </dl>
            </div>
            <p>
      This section will show you how to run JBoss AOP with standalone applications and how to run it integrated with
      the JBoss application server.
   </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="d0e4263"/>10.1. Loadtime, Compiletime and HotSwap Modes</h2>
                     </div>
                  </div>
               </div>
               <p>
      There are
      3 different modes to run your aspectized applications.  Precompiled, loadtime or hotswap.  JBoss AOP needs to weave your aspects
      into the classes which they aspectize.  You can choose to use JBoss AOP's precompiler to accomplish this (Compiletime) or have this
      weavining happen at runtime either when the class is loaded (Loadtime) or after it (HotSwap).
      </p>
               <p>
         Compiletime happens before you run your application.
         Compiletime weaving is done by using the JBoss AOP precompiler to weave in your aspects to existing .class files.
         The way it works is that you run the JBoss AOP precompiler on a set of .class files and those files will be modified
         based on what aspects you have defined.  Compiletime weaving isn't always the best choice though.  JSPs are a good
         instance where compiletime weaving may not be feasible.  It is also perfectly reasonable to mix and match compile time and load time though.
         If you have load-time transformation enabled, precompiled aspects are not transformed when they are loaded and ignored by the classloader transformer.
      </p>
               <p>
      Loadtime weaving offers the ultimate flexibility.  JBoss AOP does not require a special classloader to do loadtime weaving, but there
      are some issues that you need to think about. The Java Virtual Machine actually has a simple standard mechanism of hooking in a class transformer
         through the <code class="literal">-javaagent</code>.  JBoss AOP an additional load-time transformer that can hook into classloading via this standard mechanism.
      </p>
               <p>
          Load-time weaving also has other serious side effects that you need to be aware of.  JBoss AOP needs to do the same kinds of things that any standard Java
          profiling product needs to do.  It needs to be able to process bytecode at runtime.  This means that boot can end up being significantly slowed down because
          JBoss AOP has to do a lot of work before a class can be loaded.  Once all classes are loaded though, load-time weaving has zero effect on the speed
          of your application.  Besides boottime, load-time weaving has to create a lot of Javassist datastructure that represent the bytecode of a particular class.
          These datastructures consume a lot of memory.  JBoss AOP does its best to flush and garbage collect these datastructures, but some must
          be kept in memory.  We'll talk more about this later.
       </p>
               <p>
          HotSwap weaving is a good choice if you need to enable aspects in runtime and don't want that the flow control of your classes be changed before that.
          When using this mode, your classes are instrumented a minimum necessary before getting loaded, without affecting the flow control. If any joinpoint becomes
          intercepted in runtime due to a dynamic AOP operation, the affected classes are weaved, so that the added interceptors and aspects can be invoked. As the
          previous mode, hot swap contains some drawbacks that need to be considered.
       </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="standalone"/>10.2. Regular Java Applications</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AOP does not require an application server to be used.  Applications running JBoss AOP can be run
         standalone outside of an application server in any standard Java application.  This section focuses on
         how to run JBoss AOP applications that don't run in the JBoss application server.

      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="standalone-compiletime"/>10.2.1. Precompiled instrumentation</h3>
                        </div>
                     </div>
                  </div>
                  <p>
             Running a precompiled aop application is quite similar to running a normal java
             application. In addition to the classpath required for your application you need
             to specify the files required for aop, which are the files in the distribution's
             <code class="literal">lib/</code> folder.
         </p>
                  <p>
            As an alternative, you can replace all those jars by
            <code class="literal">jboss-aop-single.jar</code>, that bundles the 
            libraries used by JBoss AOP with JBoss AOP class files in a single jar.
         </p>
                  <p>
            JBoss AOP finds XML configuration files in these two ways:
            </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
                  You tell JBoss AOP where the XML files are.  Set the
                  <code class="literal">jboss.aop.path</code> system property. (You can specify
                  multiple files or directories separated by ':' (*nix) or ';' (Windows), i.e.
                  <code class="literal">-Djboss.aop.path=jboss-aop.xml;metadata-aop.xml</code>)
                  If you specify a directory, all
                  <code class="literal">aop.xml</code> files will be loaded from there as well.
               </li>
                        <li>
                  Let JBoss AOP figure out where XML files are.  JBoss AOP will look for all XML files that match this
                  pattern  <code class="literal">/META-INF/jboss-aop.xml</code>.  So, if you package your jars and put your JBoss AOP
                  XML files within <code class="literal">/META-INF/jboss-aop.xml</code>, JBoss AOP will find these files.
               </li>
                     </ul>
                  </div>
                  <p>
         
                  </p>
                  <p>
            If you are using annotated bindings (See Chapter "Annotated Bindings"), you must tell JBoss AOP
            which JARS or directories that may have annotated @Aspects.  To do this you must set the
            <code class="literal">jboss.aop.class.path</code>  system property. (You can specify
                  multiple jars or directories separated by ':' (*nix) or ';' (Windows), i.e.
            <code class="literal">-Djboss.aop.class.path=aspects.jar;classes</code>)
         </p>
                  <p>
            So to run a precompiled AOP application, where your jboss-aop.xml file is not part of
            a jar, you enter this at a command prompt:
            </p>
                  <pre class="programlisting">
$ java -cp=&lt;classpath as described above&gt; -Djboss.aop.path=&lt;path to jboss-aop.xml&gt; \
         -Djboss.aop.class.path=aspects.jar
         com.blah.MyMainClass
            </pre>
                  <p>
         
                  </p>
                  <p>
            To run a precompiled AOP application, where your application contains a jar
            with a META-INF/jboss-aop.xml file, you would need to do this from the command-line:
            </p>
                  <pre class="programlisting">
$ java -cp=&lt;classpath as described above&gt; com.blah.MyMainClass
            </pre>
                  <p>
         
                  </p>
                  <p>
            In the /bin folder of the distribution we have provided batch/script files to make
            this easier. It includes all the aop libs for you, so you just have to worry
            about your files. The usage:
            </p>
                  <pre class="programlisting">
$ run-precompiled classpath [-aoppath path_to_aop.xml] [-aopclasspath path_to_annotated] \
      com.blah.MyMainClass [args...]
            </pre>
                  <p>
            If your application is not in a jar with a META-INF/jboss-aop.xml file, you must
            specify the path to your
            <code class="literal">*-aop.xml</code> files in the
            <code class="literal">-aoppath</code> parameter, and if your class comtains aspects configured
            via annotations (
            <code class="literal">@Aspect</code> etc.) you must pass in this classpath
            via the
            <code class="literal">-aopclasspath</code> parameter. 
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4355"/>10.2.2. Loadtime</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            This section describes how to use loadtime instrumentation of classes with aop. The
            classes themselves are just compiled using Java, but are not precompiled with the aop
            precompiler. 
            In the examples given
            if your classes are contained in a jar with a META-INF/jboss-aop.xml file, you
            would omit the
            <code class="literal">-Djboss.aop.path</code> system property.
         </p>
                  <p>
            The JVM has a pluggable way of defining a class transformer via the
               <code class="literal">java.lang.instrument</code>
            package.  JBoss AOP uses this mechanism to weave aspects at class load time.
            Using loadtime weaving is really easy.  All you have to do is define an additional standard switch
            on the Java command line.
            <code class="literal">-javaagent:jboss-aop.jar</code>. 
            Here's how run an AOP application with loadtime instrumentation,
            where your jboss-aop.xml file is not part of a jar:
            </p>
                  <pre class="programlisting">
$ java -cp=&lt;classpath as described above&gt; -Djboss.aop.path=&lt;path to jboss-aop.xml&gt; \
      -javaagent:jboss-aop.jar com.blah.MyMainClass
            </pre>
                  <p>
         
                  </p>
                  <p>
            And to run an AOP application with loadtime instrumentation,
            where your application contains a jar with a META-INF/jboss-aop.xml file:
            </p>
                  <pre class="programlisting">
$ java -cp=&lt;classpath as described above&gt; -javaagent:jboss-aop.jar \
      com.blah.MyMainClass
            </pre>
                  <p>
         
                  </p>
                  <p>
            In the /bin folder of the distribution we have provided batch/script files to make
            this easier. It includes all the aop libs for you, so you just have to worry
            about your files. The usage:
            </p>
                  <pre class="programlisting">
$ run-load classpath [-aoppath path_to_aop.xml] [-aopclasspath path_to_annotated] \
      com.blah.MyMainClass [args...]
            </pre>
                  <p>
            The parameters have the same meaning as for the run-precompiled scripts.
         </p>
                  <p>
            If you invoke the previous
            <code class="literal">java</code> examples with ant, by using
            the ant
            <code class="literal">java</code> task, make sure that you set
            <code class="literal">fork="true"</code> in the ant
            <code class="literal">java</code> task. Failure
            to do so, causes the
            <code class="literal">java</code> task to execute in the same VM
            as ant which is already running. This means that the special classloader used to
            do the loadtime transformations does not replace the standard one, so no
            instrumentation takes place.
         </p>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="d0e4401"/>10.2.2.1. Loadtime using JRockit</h4>
                           </div>
                        </div>
                     </div>
                     <p>
            JRockit 5+ supports the "normal" -javaagent switch.
           </p>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="d0e4406"/>10.2.2.2. Improving Loadtime Performance</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               JBoss AOP needs to do the same kinds of things that any standard Java
               profiling product needs to do.  It needs to be able to process bytecode at runtime before a class is loaded.
              JBoss AOP has to do a lot of work before a class can be loaded.  This means that boot time can end up being significantly slowed down.
               Once all classes are loaded though, load-time weaving has zero effect on the speed
               of your application.
            </p>
                     <p>
                Besides boottime, load-time weaving has to create a lot of Javassist datastructures that represent the bytecode of a particular class.
               These datastructures consume a lot of memory.  JBoss AOP does its best to flush and garbage collect these datastructures, but some must
               be kept in memory.  This section focuses on how you can improve the performance of Loadtime weaving.
            </p>
                     <div class="variablelist">
                        <dl>
                           <dt>
                              <span class="term">Increase the Java Heapspace</span>
                           </dt>
                           <dd>
                              <p>
                        In Java, when your application is getting close to eating up all of its memory/heapspace, the Java
                        Garbage Collector starts to run more frequently and aggressively.  When the GC starts running more often
                        the performance of your application will suffer.  JBoss AOP does its best to balance bootup speed vs.
                        memory consumption, but it does require loading bytecode into Javassist datastructures so it can analyze
                        and transform a class.  For speed purposes, the datastructures are cached thus leading to the extra memory consumption.
                        Javassist structures of non-transformed classes are placed a SoftReference cache, so they are GC'd when memory is running low.
                        Transformed classes, however, are locked in the cache.  Transformed classes are help in memory, as they may effect
                        pointcut matching on classes that haven't been loaded yet.
                     </p>
                              <p>
                        To increase your Heap size, use the standard <code class="literal">-Xmx</code> switch.
                     </p>
                           </dd>
                           <dt>
                              <span class="term">Filtering</span>
                           </dt>
                           <dd>
                              <p>
                     Filtering probably has the greatest effect on overall boot-time speed.
                     If you've ever worked with a Java profiling product before, you probably noticed that it has an option
                     to filter classes that you are not interested in profiling.  This can speed up performance of the tool.
                     JBoss AOP has to analyze every class in the system to make sure it does not need to be transformed.  THis
                      is one reason why load-time weaving can be so slow.  You can give JBoss AOP a lot of help by specifying
                      sets of classes that do not need to be transformed.
                  </p>
                              <p>
                     To enable filtering, you can use the <code class="literal">jboss.aop.exclude</code> System Property. This System Property
                     is a comma delimited list.  The strings in the list can be package names and/or classnames.  Packages/classes within
                     this list will ignored by JBoss AOP. You can use the wildcard <code class="literal">*</code> in place of a classname, this
                     will then exclude all classes. No other wildcards are supported.
                  </p>
                              <pre class="programlisting">
                     java -Djboss.aop.exclude=org.jboss,org.apache ...
                  </pre>
                              <p>
                     There is also a mirror opposite of exclude.  The System Property <code class="literal">jboss.aop.include</code> overrides any thing
                     specified with exclude.
                  </p>
                           </dd>
                           <dt>
                              <span class="term">Include ignored annotations</span>
                           </dt>
                           <dd>
                              <p>
                     To improve the startup time of JBoss AOP all invisible annotations (invisible annotations are all annotations that are not
                     annotated with <code class="literal">@Retention(RetentionPolicy.RUNTIME)</code>) are ignored by default.
                     To include them use the system property <code class="literal">jboss.aop.invisible.annotations</code> to add packages that will be
                     included, or add "*" to include all.
                  </p>
                              <pre class="programlisting">
                      java -Djboss.aop.include.annotations=com.foo.bar,org.my.company
                    </pre>
                              <p>
                    To include all:
                  </p>
                              <pre class="programlisting">
                      java -Djboss.aop.include.annotations=*
                    </pre>
                           </dd>
                           <dt>
                              <span class="term">Turn off optimizations</span>
                           </dt>
                           <dd>
                              <p>
                     To increase overall runtime performance, JBoss AOP has to dynamically create a lot of extra code.
                     If you turn off these optimizations, JBoss AOP can weave a bit quicker.  There is a good chance, depending on your application
                     that you will not even notice that these optimizations are turned off.  See <a href="#insrumentation-modes" title="Chapter 14. Instrumentation Modes">Chapter 14, <i xmlns:xlink="http://www.w3.org/1999/xlink">Instrumentation Modes</i>
                                 </a>
                     for how to switch between weaving modes.
                  </p>
                           </dd>
                           <dt>
                              <span class="term">Turn off pruning</span>
                           </dt>
                           <dd>
                              <p>
                     JBoss AOP tries to aggressive prune cached Javassist structures.  This may, may not have a tiny effect
                     on performance.  The <code class="literal">jboss.aop.prune</code>
                     system property can be set to turn off pruning.
                  </p>
                              <pre class="programlisting">
                     java -Djboss.aop.prune=false ...
                  </pre>
                           </dd>
                           <dt>
                              <span class="term">-client/-server</span>
                           </dt>
                           <dd>
                              <p>
                        Strangely enough, it seems that the -client VM switch is a little faster for JBoss AOP loadtime weaving
                        that -server.   If you are using the -server VM, trying switching to -client (the default).
                     </p>
                           </dd>
                           <dt>
                              <span class="term">Ignore</span>
                           </dt>
                           <dd>
                              <p>
                        A way to completely ignore classes from being instrumented. This overrides whatever you have set up using the include/exclude filters. The system property
                        is <code class="literal">jboss.aop.ignore</code>, and you can use wildcards in the classnames. As for include/exclude you may specify a comma separated list of class
                        name patterns. This following example avoids instrumenting the cglib generated proxies for hibernate:
                  	  </p>
                              <pre class="programlisting">
                        java -Djboss.aop.ignore=*$$EnhancerByCGLIB$$*
                  	</pre>
                              <p>
                     
                              </p>
                           </dd>
                        </dl>
                     </div>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4502"/>10.2.3. HotSwap</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            The HotSwap feature allows bytecode of your classes to be weaved in runtime. This results in application flow control changes
            to your classes only when joinpoints become intercepted (to do this, use the dynamic aop funcionality provided by JBoss AOP).
            This is a mode to be considered when you want to assure the flow control of your classes will be kept intact until a binding or
            a interceptor is added.
         </p>
                  <p>
            This mode is currently provided through the <code class="literal">java.lang.instrument.Instrumentation</code> hot swap functionality,
            which is part of the JVMTI (Java Virtual Machine Tool Interface). So, you cannot run JBoss AOP in this mode when
            using a previous JDK version.
         </p>
                  <p>
            To enable HotSwap, you have to add an argument to the Java command line in a very similar way to the Loadtime mode:
            <code class="literal">-javaagent:jboss-aop.jar=-hotSwap</code>.
            The difference is that the <code class="literal">-hotSwap</code> argument was added to the agent parameter list.
         </p>
                  <p>
            This way, if your jboss-aop.xml file is contained in a jar file, run:
            </p>
                  <pre class="programlisting">
$ java -cp=&lt;classpath as described above&gt; -Djboss.aop.path=&lt;path to jboss-aop.xml&gt; \
		-javaagent:jboss-aop.jar=-hotSwap com.blah.MyMainClass
            </pre>
                  <p>
         
                  </p>
                  <p>
            And if your jboss-aop.xml file is contained in a jar, run the following command line:
            </p>
                  <pre class="programlisting">
$ java -cp=&lt;classpath as described above&gt; -javaagent:jboss-aop.jar=-hotSwap \
		com.blah.MyMainClass
            </pre>
                  <p>
         
                  </p>
                  <p>
            The <code class="literal">run-loadHotSwap</code> batch/script files contained in the /bin folder of the distribution are similar to the
            <code class="literal">run-load</code> ones, described in the previous subsection. All aop libs are included in these script files.
            To use them, run:
            </p>
                  <pre class="programlisting">
$ run-load classpath [-aoppath path_to_aop.xml] [-aopclasspath path_to_annotated] \
		com.blah.MyMainClass [args...]
            </pre>
                  <p>
         
                  </p>
                  <p>
            When hotswap is enabled, the prunning of classes is turned off. Therefore, if you try to configure the jboss.aop.prune option as
               <code class="literal"> true</code>, this setup will be ignored.
         </p>
                  <p>
            As with the Loadtime mode, the HotSwap mode results in a boot time delay. Besides this drawback, the execution of some dynamic aop operations
            may be slower than in the other modes, when classes need to be hot swapped. The available options to tune performance are the same as described
            in the "Improving Loadtime Performance" subsection, except the pruning of classes.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4548"/>10.2.4. User-Defined ClassLoaders</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            In order to be compatible with JBoss AOP, the ClassLoader responsible for loading your application's classes must be able to find class files
            as resources. This means that, given the name of a class that is in the classpath of your application, the methods below must all return the
            URL(s) of the corresponding class file(s):
           </p>
                  <pre class="programlisting">
public URL getResource(String name)
public Enumeration&lt;URL&gt; getResources(String name) throws IOException
public Enumeration&lt;URL&gt; getResourceAsStream(String name) throws IOException
            </pre>
                  <p>
         
                  </p>
                  <p>
            Usually, there is no need to be concerned about this, as the ClassLoader implementations of Sun's JVM and JRockit follow the requirement
            above. On the other hand, if the application is being run with a user-defined ClassLoader, it is necessary to make sure the ClassLoader
            follows this important requirement.
         </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="jboss"/>10.3. JBoss Application Server</h2>
                     </div>
                  </div>
               </div>
               <p>
         JBoss AOP is integrated with JBoss 4.0.1+ application server.  The integration steps are different
         depending on what version of JBoss AS you are using and what JDK version you are using.  It is also dependent
         on whether you want to use loadtime or compiletime instrumentation. JBoss 4.x comes with previous versions of JBoss
         AOP, which can be upgraded to AOP 2.0.x by using the ant scripts as explained in <a href="#installing-jboss40-jdk50" title="8.2. Installing with JBoss 4.0.x and JBoss 4.2.x Application Server for JDK 5">Section 8.2, “Installing with JBoss 4.0.x and JBoss 4.2.x Application Server for JDK 5”</a>.
         JBoss 5 comes with AOP 2.0.x built in.
      </p>
               <p>
         Based on what JDK you are on and what loadtime weaving option you want to you, you must configure JBoss AS differently.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4567"/>10.3.1. Packaging AOP Applications</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            To deploy an AOP application in JBoss you need to package it. AOP is packaged similarly
            to SARs(MBeans). You can either deploy an XML file directly in the deploy/ directory
            with the signature *-aop.xml along with your package (this is how the base-aop.xml,
            included in the
            <code class="literal">jboss-aop.deployer</code> file works) or you can include it in
            the jar file containing your classes. If you include your xml file in your jar,
            it must have the file extension .aop and a jboss-aop.xml file must be contained
            in a META-INF directory, i.e.
            <code class="literal">META-INF/jboss-aop.xml</code>.
         </p>
                  <p>
            Note that in JBoss 5, you MUST specify the schema used, otherwise your information will not be
            parsed correctly. You do this by adding the <code class="literal">xmlns="urn:jboss:aop-beans:1:0</code> 
            attribute to the root <code class="literal">aop</code> element, as shown here: 
            </p>
                  <pre class="programlisting">
&lt;aop xmlns="urn:jboss:aop-beans:1.0"&gt;


&lt;/aop&gt;
            
            </pre>
                  <p>
         
                  </p>
                  <p>
            If you want to create anything more than a non-trivial example, using the .aop jar
            files, you can make any top-level deployment contain a .aop file containing the xml
            binding configuration. That is you can have a .aop file in an .ear file, or a .aop
            file in a war file etc. The bindings specified in the
            <code class="literal">META-INF/jboss-aop.xml</code>
            file contained in the .aop file will affect all the classes in the whole war!
         </p>
                  <p>
            To pick up a .aop file in an .ear file, it must be listed in the
            <code class="literal">.ear/META-INF/application.xml</code> as a java module, e.g.:
         </p>
                  <pre class="programlisting">

&lt;?xml version='1.0'  encoding='UTF-8'?&gt;
&lt;!DOCTYPE application PUBLIC '-//Sun Microsystems, Inc.//DTD J2EE Application 1.2//EN'
                             'http://java.sun.com/j2ee/dtds/application_1_2.dtd'&gt;

&lt;application&gt;
    &lt;display-name&gt;AOP in JBoss example&lt;/display-name&gt;
    &lt;module&gt;
        &lt;java&gt;example.aop&lt;/java&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;aopexampleejb.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;web&gt;
           &lt;web-uri&gt;aopexample.war&lt;/web-uri&gt;
          &lt;context-root&gt;/aopexample&lt;/context-root&gt;
       &lt;/web&gt;
   &lt;/module&gt;
&lt;/application&gt;

			</pre>
                  <p>
			   Note that in newer versions of JBoss (&gt;= 4.0.5), the contents of the .ear file are deployed in the order they
			   are listed in the application.xml. When using loadtime weaving the bindings listed in the example.aop file must be
			   deployed before the classes being advised are deployed, so that the bindings exist in the system before the
			   ejb, servlet etc. classes are loaded. This is acheived by listing the .aop file at the start of the application.xml.
			   Older versions of JBoss did not have this issue since the contained .aop files were deployed before anything else, and
			   this still holds true for other types of archives such as .sar and .war files.
			</p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4603"/>10.3.2. The JBoss AspectManager Service</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            The AspectManager Service is installed in both JBoss 5 and JBoss 4.x. It can be managed at run time
            using the JMX console which is found at <code class="literal">http://localhost:8080/jmx-console</code>. It is
            registered under the ObjectName <code class="literal">jboss.aop:service=AspectManager</code>. If you want to configure
            it on startup you need to edit some configuration files, which are different on JBoss 5 and JBoss 4.x, although
            the concepts are the same.
          </p>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="d0e4614"/>10.3.2.1. JBoss 5 AspectManager Service</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               In JBoss 5 the AspectManager Service is configured using a JBoss Microcontainer bean. The configuration file
               is <code class="literal">jboss-5.x.x.GA/server/xxx/conf/aop.xml</code>. The AspectManager Service is deployed with
               the following xml:
            </p>
                     <pre class="programlisting">

   &lt;bean name="AspectManager" class="org.jboss.aop.deployers.AspectManagerJDK5"&gt;
      ...
      
      &lt;property name="jbossIntegration"&gt;&lt;inject bean="AOPJBossIntegration"/&gt;&lt;/property&gt;

      &lt;property name="enableLoadtimeWeaving"&gt;false&lt;/property&gt;
      &lt;!-- only relevant when EnableLoadtimeWeaving is true.
           When transformer is on, every loaded class gets
           transformed.  If AOP can't find the class, then it
           throws an exception.  Sometimes, classes may not have
           all the classes they reference.  So, the Suppressing
           is needed.  (i.e. Jboss cache in the default configuration --&gt;
      &lt;property name="suppressTransformationErrors"&gt;true&lt;/property&gt;
      &lt;property name="prune"&gt;true&lt;/property&gt;
      &lt;property name="include"&gt;org.jboss.test., org.jboss.injbossaop.&lt;/property&gt;
      &lt;property name="exclude"&gt;org.jboss.&lt;/property&gt;
      &lt;!-- This avoids instrumentation of hibernate cglib enhanced proxies
      &lt;property name="ignore"&gt;*$$EnhancerByCGLIB$$*&lt;/property&gt; --&gt;
      &lt;property name="optimized"&gt;true&lt;/property&gt;
      &lt;property name="verbose"&gt;false&lt;/property&gt;
      &lt;!--
         Available choices for this attribute are:
            org.jboss.aop.instrument.ClassicInstrumentor (default)
            org.jboss.aop.instrument.GeneratedAdvisorInstrumentor
       &lt;property name="instrumentor"&gt;org.jboss.aop.instrument.ClassicInstrumentor&lt;/property&gt;
      --&gt;
          &lt;!-- 
                By default the deployment of the aspects contained in 
                ../deployers/jboss-aop-jboss5.deployer/base-aspects.xml
                are not deployed. To turn on deployment uncomment this property
          &lt;property name="useBaseXml"&gt;true&lt;/property&gt;
          --&gt;
   &lt;/bean&gt;

               
            </pre>
                     <p>
               In later sections we will talk about changing the class of the AspectManager Service, to
               do this replace the contents of the <code class="literal">class</code> attribute of the 
               <code class="literal">bean</code> element.
            </p>
                  </div>
                  <div class="sect3" lang="en">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title">
                                 <a id="d0e4632"/>10.3.2.2. JBoss 4.x AspectManager Service</h4>
                           </div>
                        </div>
                     </div>
                     <p>
               In JBoss 4.x the AspectManager Service is configured using a JBoss Microcontainer bean. The configuration file
               is <code class="literal">jboss-4.x.x.GA/server/default/deploy/jboss-aop-jdk50.deployer/META-INF/jboss-service.xml</code>. 
               The AspectManager Service is deployed with
               the following xml:
            </p>
                     <pre class="programlisting">

   &lt;mbean code="org.jboss.aop.deployment.AspectManagerServiceJDK5"
      name="jboss.aop:service=AspectManager"&gt;
      &lt;attribute name="EnableLoadtimeWeaving"&gt;false&lt;/attribute&gt;
      &lt;!-- only relevant when EnableLoadtimeWeaving is true.  
           When transformer is on, every loaded class gets 
           transformed.  If AOP can't find the class, then it 
           throws an exception.  Sometimes, classes may not have 
           all the classes they reference.  So, the Suppressing 
           is needed.  (i.e. Jboss cache in the default configuration --&gt;
      &lt;attribute name="SuppressTransformationErrors"&gt;true&lt;/attribute&gt;
      &lt;attribute name="Prune"&gt;true&lt;/attribute&gt;
      &lt;attribute name="Include"&gt;org.jboss.test, org.jboss.injbossaop&lt;/attribute&gt;
      &lt;attribute name="Exclude"&gt;org.jboss.&lt;/attribute&gt;
      &lt;!-- This avoids instrumentation of hibernate cglib enhanced proxies
      &lt;attribute name="Ignore"&gt;*$$EnhancerByCGLIB$$*&lt;/attribute&gt; --&gt;
      &lt;attribute name="Optimized"&gt;true&lt;/attribute&gt;
      &lt;attribute name="Verbose"&gt;false&lt;/attribute&gt;
      &lt;depends optional-attribute-name="JBossIntegrationWrapper" proxy-type="attribute"&gt;jboss.aop:service=JBoss4IntegrationWrapper&lt;/depends&gt;
      &lt;!-- 
         Available choices for this attribute are:
            org.jboss.aop.instrument.ClassicInstrumentor (default)
            org.jboss.aop.instrument.GeneratedAdvisorInstrumentor
       &lt;attribute name="Instrumentor"&gt;org.jboss.aop.instrument.ClassicInstrumentor&lt;/attribute&gt;
      --&gt;
   &lt;/mbean&gt;

               
            </pre>
                     <p>
               In later sections we will talk about changing the class of the AspectManager Service, to
               do this replace the contents of the <code class="literal">code</code> attribute of the 
               <code class="literal">mbean</code> element.
            </p>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="running-as-sun-jdk"/>10.3.3. Loadtime transformation in JBoss AS Using Sun JDK</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            JBoss AS has special integration with JDK (from version 5.0 on) to do loadtime transformations.  This section explains how to use it.
         </p>
                  <p>
            If you want to do load-time
            transformations with JBoss 5 and Sun JDK, these are the steps you must take.
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
               Set the <code class="literal">enableLoadtimeWeaving</code> attribute/property to true.  
               By default, JBoss application server will not do load-time bytecode manipulation
               of AOP files unless this is set. If <code class="literal">suppressTransformationErrors</code>
               is <code class="literal">true</code> failed bytecode transformation will only give an error warning. This flag is
               needed because sometimes a JBoss deployment will not have all the classes a class references.
		        </li>
                        <li>
		         Copy the <code class="literal">pluggable-instrumentor.jar</code> from the <code class="literal">lib/</code> 
		         directory of your JBoss AOP distribution to the <code class="literal">bin/</code> directory of your 
		         JBoss AOP application server installation.  
		       </li>
                        <li>
		         Next edit <code class="literal">run.sh</code> or 
		         <code class="literal">run.bat</code> (depending on what OS you're on) and add the following to the JAVA_OPTS environment
		         variable:
		            <pre class="programlisting">
set JAVA_OPTS=%JAVA_OPTS% -Dprogram.name=%PROGNAME% -javaagent:pluggable-instrumentor.jar
		            </pre>
                        </li>
                     </ul>
                  </div>
                  <p>
            Note that the class of the AspectManager Service must be <code class="literal">org.jboss.aop.deployers.AspectManagerJDK5</code>
            on JBoss 5, or <code class="literal">org.jboss.aop.deployment.AspectManagerServiceJDK5</code> as these are what work with the -javaagent weaver.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4699"/>10.3.4. JBoss 5 and JRockit</h3>
                        </div>
                     </div>
                  </div>
                  <p>
         JRockit also supports the -javaagent switch mentioned in <a href="#running-as-sun-jdk" title="10.3.3. Loadtime transformation in JBoss AS Using Sun JDK">Section 10.3.3, “Loadtime transformation in JBoss AS Using Sun JDK”</a>. If you wish to 
         use that, then the steps in <a href="#running-as-sun-jdk" title="10.3.3. Loadtime transformation in JBoss AS Using Sun JDK">Section 10.3.3, “Loadtime transformation in JBoss AS Using Sun JDK”</a> are sufficient. However, JRockit also comes
         with its own framework for intercepting when classes are loaded, which might be faster than the -javaagent switch.
         If you wish to use this, there are three steps you must take.
      </p>
                  <p>
            If you want to do load-time
            transformations with JBoss 5 and JRockit using the special JRockit hooks, these are the steps you must take.
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
               Set the <code class="literal">enableLoadtimeWeaving</code> attribute/property to true.  
               By default, JBoss application server will not do load-time bytecode manipulation
               of AOP files unless this is set. If <code class="literal">suppressTransformationErrors</code>
               is <code class="literal">true</code> failed bytecode transformation will only give an error warning. This flag is
               needed because sometimes a JBoss deployment will not have all the classes a class references.
              </li>
                        <li>
               Copy the <code class="literal">jrockit-pluggable-instrumentor.jar</code> from the <code class="literal">lib/</code> 
               directory of your JBoss AOP distribution to the <code class="literal">bin/</code> directory of your 
               JBoss AOP application server installation.  
             </li>
                        <li>
               Next edit <code class="literal">run.sh</code> or 
               <code class="literal">run.bat</code> (depending on what OS you're on) and add the following to the JAVA_OPTS 
                and JBOSS_CLASSPATH environment variables:
                  <pre class="programlisting">
# Setup JBoss sepecific properties
JAVA_OPTS="$JAVA_OPTS -Dprogram.name=$PROGNAME \
   -Xmanagement:class=org.jboss.aop.hook.JRockitPluggableClassPreProcessor"
JBOSS_CLASSPATH="$JBOSS_CLASSPATH:jrockit-pluggable-instrumentor.jar"
                  </pre>
                        </li>
                        <li>
               Set the class of the AspectManager Service to be <code class="literal">org.jboss.aop.deployers.AspectManagerJRockit</code>
               on JBoss 5, or <code class="literal">org.jboss.aop.deployment.AspectManagerService</code> as these are what work with 
               special hooks in JRockit.
              </li>
                     </ul>
                  </div>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4752"/>10.3.5. Improving Loadtime Performance in a JBoss AS Environment</h3>
                        </div>
                     </div>
                  </div>
                  <p>
         The same rules apply to JBoss AS for tuning loadtime weaving performance as standalone Java.  See the previous chapter on
         tips and hints.  YOU CANNOT USE THE SAME SYSTEM PROPERTIES THOUGH!  Switches like pruning, optimized, and include/exclude
         are configured through the jboss-aop.deployer/META-INF/jboss-service.xml file talked about earlier in this chapter.
         You should be able to figure out how to turn the switches on/off from the above documentation.
      </p>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="d0e4757"/>10.4. Scoping aop to the classloader</h2>
                     </div>
                  </div>
               </div>
               <p>
         By default all deployments in JBoss are global to the whole application server. That means that any ear, sar, jar etc. that is
         put in the deploy directory can see the classes from any other deployed archive. Similarly, aop bindings are global to the whole
         virtual machine. This "global" visibility can be turned off per top-level deployment.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4762"/>10.4.1. Deploying as part of a scoped classloader</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            How the following works may be changed in future versions of jboss-aop. If you deploy a .aop file as part of a
            scoped archive, the bindings etc. applied within the .aop/META-INF/jboss-aop.xml file will only apply to the classes within the scoped archive
            and not to anything else in the application server. Another alternative is to deploy -aop.xml files as part of a service
            archive (SAR). Again if the SAR is scoped, the bindings contained in the -aop.xml files will only apply to the contents of the SAR
            file. It is not currently possible to deploy a standalone -aop.xml file and have that attach to a scoped deployment. Standalone
            -aop.xml files will apply to classes in the whole application server.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="d0e4767"/>10.4.2. Attaching to a scoped deployment</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            If you have an application using classloader isolation, as long as you have "prepared your classes" you can later attach a .aop file to that deployment. If
            we have a .ear file scoped using a jboss-app.xml file, with the scoped loader repository <code class="literal">jboss.test:service=scoped</code>:
         </p>
                  <pre class="programlisting">&lt;jboss-app&gt;
  &lt;loader-repository&gt;
      jboss.test:service=scoped
  &lt;/loader-repository&gt;
&lt;/jboss-app&gt;</pre>
                  <p>We can later deploy a .aop file containing aspects and configuration to attach that deployment to the scoped .ear. This is done using the <code class="literal">loader-repository</code>
         tag in the .aop files <code class="literal">META-INF/jboss-aop.xml</code> file.
         </p>
                  <pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;aop&gt;
   &lt;loader-repository&gt;jboss.test:service=scoped&lt;/loader-repository&gt;

   &lt;!-- Aspects and bindings --&gt;
&lt;/aop&gt;</pre>
                  <p>This has the same effect as deploying the .aop file as part of the .ear as we saw previously, but allows you to hot deploy aspects into your scoped application.</p>
               </div>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="maven"/>Chapter 11. Building JBoss AOP with Maven2</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#compiling_maven">11.1. AOP Compile with Maven2</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#compiletests">11.2. AOP Compile tests with Maven2</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#maven_running">11.3. Running precompiled with Maven2</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#runningweaving">11.4. Running loadtime weaving with Maven2</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#runningtests">11.5. Running tests with Maven2</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <p>
    Since JBoss AOP requires either loadtime or compiletime weaving we need to customize maven a bit
    to make it do what we want. JBoss AOP provides plugins to make this weaving as easy as possible.
  </p>
            <p>
    The JBoss AOP plugin is named jbossaop and is provided under the maven2 jboss.org repository. 
    For the final releases use:
    </p>
            <pre class="programlisting">
&lt;repository&gt;
   &lt;id&gt;maven.jboss.org&lt;/id&gt;
   &lt;name&gt;JBoss Maven Repository&lt;/name&gt;
   &lt;url&gt;http://repository.jboss.com/maven2&lt;/url&gt;
&lt;/repository&gt; </pre>
            <p>
    If you want to use the snapshot releases use:
    </p>
            <pre class="programlisting">
&lt;repository&gt;
   &lt;id&gt;snapshots.jboss.org&lt;/id&gt;
   &lt;name&gt;JBoss Maven Snapshot Repository&lt;/name&gt;
   &lt;url&gt;http://snapshots.jboss.org/maven2&lt;/url&gt;
&lt;/repository&gt;</pre>
            <p>

    The jbossaop maven plugin will provide all the aop dependencies needed to weave and run. There is no need
    to include aop dependencies other than the plugin.

    NOTE: The version used in these examples may be obsolete, please check the latest release for the reference
    version instead of using the version in these examples.

  </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="compiling_maven"/>11.1. AOP Compile with Maven2</h2>
                     </div>
                  </div>
               </div>
               <p>
    The aop compile plugin is configured to run after the default maven compile phase has ended. By default it
    will try to find the jboss-aop.xml file in <code class="literal">src/main/resources/jboss-aop.xml</code>. It will also
    try to weave every class in <code class="literal">$project.build.outputDirectory</code> (usually target/classes).
    List of options:
    </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <p>
          
                           <code class="literal">aoppaths</code> - an array of possible jboss-aop.xml files. Default is 
          <code class="literal">src/main/resources/jboss-aop.xml</code>
        
                        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">verbose</code> - if set to true it will provide debug information during the aop weaving. '
          Default set to true.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">suppress</code> - suppress when a class cannot be found that a class references. 
          This may happen if code in a class references something and the class is not in the classpath. 
          Default set to true.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">noopt</code> - do not optimize the weaving. Default set to false.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">report</code> - store the output to a file (<code class="literal">aop-report.xml</code>).
          Default set to false.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">includeProjectDependency</code> - if set to true all project dependencies will also 
          be included to the aop classpath. Only needed if a class inherits a class thats not defined in
          the current module. Default set to false.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">classPath</code> - classpath, by default set to null. If its set to null it will use
          the plugin dependencies (and add project dependencies if <code class="literal">includeProjectDependency</code>
          is set) + the output build path. Do not change this if you are not sure.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">aopClassPath</code> - load xml files that adds aspects to the manager. Do not change this
          if you are not sure. By default set to null.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">includes</code> - an array of classes that will be weaved. Note that if this is specified
          just the classes thats specified here will be weaved. Default set to null.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">properties</code> - a list of properties (name, value objects) that will be added as JVM properties.
          A small example:
          </p>
                        <pre class="programlisting">&lt;properties&gt;
  &lt;property&gt;
    &lt;name&gt;log4j.configuration&lt;/name&gt;
    &lt;value&gt;log4j.properties&lt;/value&gt;
  &lt;/property&gt;
&lt;/properties&gt;</pre>
                        <p>
         This will add log4j.configuration as JVM properties like: -Dlog4j.configuration=log4j.properties. 
        </p>
                     </li>
                  </ul>
               </div>
               <p>
    There are a lot of options that can be set, but noone are mandatory (if they are mandatory 
    they have a default value set). The average user would most likely only change <code class="literal">aoppaths</code>.
    A more complete example would look like:
    </p>
               <pre class="programlisting">
&lt;plugin&gt;
  &lt;groupId&gt;org.jboss.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-jbossaop-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;compile&lt;/id&gt;
      &lt;configuration&gt;
      &lt;!-- if you want to include dependencies from the current module
           (only needed if a class inherits a class thats not defined in this module
           --&gt;
        &lt;includeProjectDependency&gt;true&lt;/includeProjectDependency&gt;
        &lt;aoppaths&gt;
          &lt;aoppath&gt;src/main/resources/jboss-aop_test2.xml&lt;/aoppath&gt;
          &lt;!-- for a second jboss-aop.xml file
          &lt;aoppath&gt;src/main/resources/jboss-aop.xml&lt;/aoppath&gt;
          --&gt;
        &lt;/aoppaths&gt;
        &lt;!-- You can specify to only aopc a specific set of classes 
        &lt;includes&gt;
          &lt;include&gt;POJO.class&lt;/include&gt;
        &lt;/includes&gt;
        --&gt;
      &lt;/configuration&gt;
      &lt;goals&gt;
        &lt;goal&gt;compile&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt; </pre>
               <p>
    
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="compiletests"/>11.2. AOP Compile tests with Maven2</h2>
                     </div>
                  </div>
               </div>
               <p>
    The only difference between aop compiling tests and non-tests are the name of the plugin. The options
    are the same for tests and non-tests. A quick example:
    </p>
               <pre class="programlisting">
&lt;plugin&gt;
  &lt;groupId&gt;org.jboss.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-jbossaop-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;compile-test&lt;/id&gt;
      &lt;configuration&gt;
        &lt;aoppaths&gt;
          &lt;aoppath&gt;src/main/resources/jboss-aop_testcase.xml&lt;/aoppath&gt;
        &lt;/aoppaths&gt;
      &lt;/configuration&gt;
      &lt;goals&gt;
        &lt;goal&gt;compile-test&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt; 
  &lt;/executions&gt;
&lt;/plugin&gt; </pre>
               <p>
    
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="maven_running"/>11.3. Running precompiled with Maven2</h2>
                     </div>
                  </div>
               </div>
               <p>
    JBoss aop run plugin is configured to run after the package phase. There are less options here than for
    the compile step and they are very similar.
    </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <p>
          
                           <code class="literal">aoppaths</code> - an array of possible jboss-aop.xml files. Default is 
          <code class="literal">src/main/resources/jboss-aop.xml</code>
        
                        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">includeProjectDependency</code> - if set to true all project dependencies will also 
          be included to the aop classpath. Only needed if a class inherits a class thats not defined in
          the current module. Default set to false.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">classPath</code> - classpath, by default set to null. If its set to null it will use
          the plugin dependencies (and add project dependencies if <code class="literal">includeProjectDependency</code>
          is set) + the output build path. Do not change this if you are not sure.
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">executable</code> - the java class that will be executed
        </p>
                     </li>
                     <li>
                        <p>
          
                           <code class="literal">properties</code> - a list of properties (name, value objects) that will be added as JVM properties.
          A small example:
          </p>
                        <pre class="programlisting">&lt;properties&gt;
  &lt;property&gt;
    &lt;name&gt;log4j.configuration&lt;/name&gt;
    &lt;value&gt;log4j.properties&lt;/value&gt;
  &lt;/property&gt;
&lt;/properties&gt;</pre>
                        <p>
         This will add log4j.configuration as JVM properties like: -Dlog4j.configuration=log4j.properties. 
        </p>
                     </li>
                  </ul>
               </div>
               <p>
    A small example using default jboss-aop.xml:
    </p>
               <pre class="programlisting">
&lt;plugin&gt;
  &lt;groupId&gt;org.jboss.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-jbossaop-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0.CR1&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;run&lt;/id&gt;
      &lt;configuration&gt;
        &lt;executable&gt;Foo&lt;/executable&gt;
      &lt;/configuration&gt;
      &lt;goals&gt;
        &lt;goal&gt;run&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt; 
  &lt;/executions&gt;
&lt;/plugin&gt; </pre>
               <p>
    
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="runningweaving"/>11.4. Running loadtime weaving with Maven2</h2>
                     </div>
                  </div>
               </div>
               <p>
    Running a java application in loadtime weaving is almost identical to compile time (except that you dont need
    to precompile it first). The only change is that we need an option to say that we want to run it loadtime.
    </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <p>
          
                           <code class="literal">loadtime</code> - set it to true if you want loadtime weaving. Default is set to false.
        </p>
                     </li>
                  </ul>
               </div>
               <p>
    A small example:
    </p>
               <pre class="programlisting">
&lt;plugin&gt;
  &lt;groupId&gt;org.jboss.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-jbossaop-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0.CR1&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;run&lt;/id&gt;
      &lt;configuration&gt;
        &lt;aoppaths&gt;
          &lt;aoppath&gt;src/main/resources/jboss-aop_testcase.xml&lt;/aoppath&gt;
        &lt;/aoppaths&gt;
        &lt;loadtime&gt;true&lt;/loadtime&gt;
        &lt;executable&gt;Test&lt;/executable&gt;
      &lt;/configuration&gt;
      &lt;goals&gt;
        &lt;goal&gt;run&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt; 
  &lt;/executions&gt;
&lt;/plugin&gt; </pre>
               <p>
    
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="runningtests"/>11.5. Running tests with Maven2</h2>
                     </div>
                  </div>
               </div>
               <p>
      Running tests with aop is a different matter since the maven tests plugin is rather complex. 
      But we can add the hooks we need to run it both compiletime and loadtime with the maven tests too.
      An example on how to run a test thats been aop compiled:
      </p>
               <pre class="programlisting">
&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.4&lt;/version&gt;
  &lt;configuration&gt;
    &lt;forkMode&gt;always&lt;/forkMode&gt;
    &lt;useSystemClassLoader&gt;true&lt;/useSystemClassLoader&gt;
    &lt;argLine&gt;-Djboss.aop.path=src/main/resources/jboss-aop_testcase.xml&lt;/argLine&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt; </pre>
               <p>
    
               </p>
               <p>
      To run it loadtime we only need to add the javaagent option to argLine. Like this:
      </p>
               <pre class="programlisting">
    &lt;argLine&gt;-javaagent:${settings.localRepository}/org/jboss/jboss-aop/2.0.0.CR3/\
    jboss-aop-2.0.0.CR3.jar \
    -Djboss.aop.path=src/main/resources/jboss-aop_testcase.xml&lt;/argLine&gt; </pre>
               <p>
    - big thanks to henrik and finn for figuring out how to do this :)
    Note again that the versions used here are just for a reference and to provide as examples. Check the JBoss AOP
    homepage for the up-to-date versions.
    </p>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="reflection"/>Chapter 12. Reflection and AOP</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#reflection-attach-chains">12.1. Force interception via reflection</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#reflection-cleaning">12.2. Clean results from reflection info methods</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <p>
         While AOP works fine for normal access to fields, methods and constructors, there are some
         problems with using the Reflection API for this using JBoss. The problems are:
         </p>
            <div class="itemizedlist">
               <ul>
                  <li>
               Intereptors/aspects bound to execution pointcuts for fields and constructors
               don't get invoked.
            </li>
                  <li>
               Intereptors/aspects bound to caller pointcuts for methods and constructors
               don't get invoked.
            </li>
                  <li>
               Reflection Methods such as <code class="literal">Class.getMethods()</code> and 
               <code class="literal">Class.getField()</code> return extra JBoss AOP "plumbing" information.
            </li>
               </ul>
            </div>
            <p>
   
            </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="reflection-attach-chains"/>12.1. Force interception via reflection</h2>
                     </div>
                  </div>
               </div>
               <p>
         To address the issues with interceptors not being invoked when you use reflection,
         we have provided a reflection aspect. You bind it to a set of caller pointcuts,
         and it mounts the pre-defined interceptor/aspect chains. The jboss-aop.xml entries 
         are:
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
    
   &lt;aspect class="org.jboss.aop.reflection.ReflectionAspect" scope="PER_VM"/&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;newInstance())"&gt;
      &lt;advice name="interceptNewInstance" \
         aspect="org.jboss.aop.reflection.ReflectionAspect"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.reflect.Constructor-&gt;newInstance(java.lang.Object[]))"&gt;
      &lt;advice name="interceptNewInstance" \
         aspect="org.jboss.aop.reflection.ReflectionAspect"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.reflect.Method-&gt;invoke(java.lang.Object, java.lang.Object[]))"&gt;
      &lt;advice name="interceptMethodInvoke" \
         aspect="org.jboss.aop.reflection.ReflectionAspect"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.reflect.Field-&gt;get*(..))"&gt;
      &lt;advice name="interceptFieldGet" \
         aspect="org.jboss.aop.reflection.ReflectionAspect"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.reflect.Field-&gt;set*(..))"&gt;
      &lt;advice name="interceptFieldSet" \
         aspect="org.jboss.aop.reflection.ReflectionAspect"/&gt;
   &lt;/bind&gt;   

         </pre>
               <p>
      
               </p>
               <p>
         The <code class="literal">ReflectionAspect</code> class provides a few hooks for you to override from
         a subclass if you like. These methods described below.
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
   protected Object interceptConstructor(
		Invocation invocation,
		Constructor constructor,
		Object[] args)
		throws Throwable;
         </pre>
               <p>
      
               </p>
               <p>
         Calls to <code class="literal">Class.newInstance()</code> and <code class="literal">Constructor.newInstance()</code>
         end up here. The default behavior is to mount any constructor execution or caller interceptor 
         chains. If you want to override the behaviour, the parameters are:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">invocation</code> - The invocation driving the chain of advices.</li>
                     <li>
                        <code class="literal">constructor</code> - The constructor being called</li>
                     <li>
                        <code class="literal">args</code>
               - the arguments being passed in to the constructor (in the case of 
               Class.newInstance(), a zero-length array since it takes no parameters)
            </li>
                  </ul>
               </div>
               <p>
      
               </p>
               <p>
         
               </p>
               <pre class="programlisting">
   protected Object interceptFieldRead(
      Invocation invocation,
      Field field,
      Object instance)
      throws Throwable;
         </pre>
               <p>
      
               </p>
               <p>
         Calls to <code class="literal">Field.getXXX()</code> end up here. The default behavior is to mount 
         any field read interceptor chains. If you want to override the behaviour, the parameters are:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">invocation</code> - The invocation driving the chain of advices.</li>
                     <li>
                        <code class="literal">field</code> - The field being read</li>
                     <li>
                        <code class="literal">instance</code> - The instance from which we are reading a non-static field.</li>
                  </ul>
               </div>
               <p>
      
               </p>
               <p>
         
               </p>
               <pre class="programlisting">
   protected Object interceptFieldWrite(
      Invocation invocation,
      Field field,
      Object instance,
      Object arg)
      throws Throwable;
         </pre>
               <p>
      
               </p>
               <p>
         Calls to <code class="literal">Field.setXXX()</code> end up here. The default behavior is to mount 
         any field write interceptor chains. If you want to override the behaviour, the parameters are:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">invocation</code> - The invocation driving the chain of advices.</li>
                     <li>
                        <code class="literal">field</code> - The field being written</li>
                     <li>
                        <code class="literal">instance</code> - The instance on which we are writing a non-static field.</li>
                     <li>
                        <code class="literal">arg</code> - The value we are setting the field to
            </li>
                  </ul>
               </div>
               <p>
      
               </p>
               <p>
         
               </p>
               <pre class="programlisting">
   protected Object interceptMethod(
		Invocation invocation,
		Method method,
		Object instance,
		Object[] args)
		throws Throwable;
         </pre>
               <p>
      
               </p>
               <p>
         Calls to <code class="literal">Method.invoke()</code> end up here. The default behavior is to mount 
         any method caller interceptor chains (method execution chains are handled correctly by default).
         If you want to override the behaviour, the parameters are:
         </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">invocation</code> - The invocation driving the chain of advices.</li>
                     <li>
                        <code class="literal">method</code> - The method being invoked</li>
                     <li>
                        <code class="literal">instance</code> - The instance on which we are invoking a non-static method.</li>
                     <li>
                        <code class="literal">args</code> - Values for the method arguments.
            </li>
                  </ul>
               </div>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="reflection-cleaning"/>12.2. Clean results from reflection info methods</h2>
                     </div>
                  </div>
               </div>
               <p>
         The <code class="literal">ReflectionAspect</code> also helps with getting rid of the JBoss AOP 
         "plumbing" information. You bind it to a set of caller pointcuts, using the 
         followingjboss-aop.xml entries :
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
   
   &lt;bind pointcut="call(* java.lang.Class-&gt;getInterfaces())"&gt;
      &lt;advice name="interceptGetInterfaces" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;getDeclaredMethods())"&gt;
      &lt;advice name="interceptGetDeclaredMethods" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;getDeclaredMethod(..))"&gt;
      &lt;advice name="interceptGetDeclaredMethod" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;getMethods())"&gt;
      &lt;advice name="interceptGetMethods" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;getMethod(..))"&gt;
      &lt;advice name="interceptGetMethod" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;getDeclaredFields())"&gt;
      &lt;advice name="interceptGetDeclaredFields" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;getDeclaredClasses())"&gt;
      &lt;advice name="interceptGetDeclaredClasses" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

   &lt;bind pointcut="call(* java.lang.Class-&gt;getDeclaredField(..))"&gt;
      &lt;advice name="interceptGetDeclaredField" \
         aspect="org.jboss.test.aop.reflection.ReflectionAspectTester"/&gt;
   &lt;/bind&gt;

         </pre>
               <p>
      
               </p>
               <p>
         This way the calls to <code class="literal">Class.getMethods()</code> etc. only return information
         that is present in the "raw" class, by filtering out the stuff added to the class by JBoss
         AOP.
      </p>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="arrays"/>Chapter 13. Interception of Array Element Access</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#array-replacement">13.1. Replacing Array Access</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#array-preparing">13.2. Preparing Array Fields</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#array-binding">13.3. Binding Advices to array element access</a>
                     </span>
                  </dt>
                  <dt>
                     <span class="sect1">
                        <a href="#array-invocations">13.4. Invocation types for array element access interception</a>
                     </span>
                  </dt>
               </dl>
            </div>
            <p>
         This chapter will show you how to intercept access to the individual elements of
         an array. The concepts are similar to the interception we have seen previously,
         but a few configuration options are introduced. Array interception can currently
         only be configured via xml. There are three steps involved.
         </p>
            <div class="itemizedlist">
               <ul>
                  <li>Specifying which classes we want to replace access to arrays in</li>
                  <li>Preparing the array fields in the target class</li>
                  <li>Binding advices to array access</li>
               </ul>
            </div>
            <p>         
   
            </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="array-replacement"/>13.1. Replacing Array Access</h2>
                     </div>
                  </div>
               </div>
               <p>
         To achieve array interception we need to replace all access to arrays within
         a selected set of classes. The <code class="literal">arrayreplacement</code> element is 
         used for this. You can either specify a particular class using the
         <code class="literal">class</code> attribute or a class expression using the 
         <code class="literal">expr</code> attribute: 
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
    
   &lt;arrayreplacement class="org.acme.POJOWithArray"/&gt;
   &lt;arrayreplacement expr="class(org.acme.*)"/&gt;

         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="array-preparing"/>13.2. Preparing Array Fields</h2>
                     </div>
                  </div>
               </div>
               <p>
         If we want to intercept an array's elements, that array field needs to be woven, using either a 
         <code class="literal">prepare</code> or a <code class="literal">bind</code> expression. If that field is within a
         class picked out by an <code class="literal">arrayreplacement</code> expression it gets all the hooks for 
         arrayreplacement to take place. The following xml along with the previous <code class="literal">arrayreplacement</code>
         weaves <code class="literal">org.acme.POJOWithArray.ints</code> for array element interception.    
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
    
   &lt;prepare expr="field(int[] org.acme.POJOWithArray-&gt;ints)"/&gt;

         </pre>
               <p>
      
               </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="array-binding"/>13.3. Binding Advices to array element access</h2>
                     </div>
                  </div>
               </div>
               <p>
         To bind advices to the access of array elements, you use a <code class="literal">arraybind</code> element.
         It binds advices to all arrays woven for array access. You can use the <code class="literal">type</code>
         attribute to specify if you want the interception to take place when setting elements in the array, 
         getting elements from the array, or both. Valid values for the <code class="literal">type</code> attribute are:
         <code class="literal">READ_WRITE</code>, <code class="literal">READ_ONLY</code> and <code class="literal">WRITE_ONLY</code>. An 
         example is shown below:
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
    
   &lt;interceptor class="org.acme.TestInterceptor"/&gt;
   &lt;arraybind type="READ_ONLY"&gt;
      &lt;interceptor-ref name="org.acme.TestInterceptor"/&gt;
   &lt;/arraybind&gt;

         </pre>
               <p>
      
               </p>
               <p>
         
                  <code class="literal">arraybind</code> currently only supports <code class="literal">interceptor-ref</code> and
         <code class="literal">advice</code> as child elements. <code class="literal">before</code>, <code class="literal">after</code>, 
         <code class="literal">throwing</code> and <code class="literal">finally</code> are not yet supported for array interception.
         for arrays.
      </p>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="array-invocations"/>13.4. Invocation types for array element access interception</h2>
                     </div>
                  </div>
               </div>
               <p>
         Writing aspects for array element interception is more or less the same as for any other joinpoint.
         However, array element interception comes with its own hierarchy of <code class="literal">Invocation</code> clases.
         Which one of these is used depends on what is being itercepted. The hierarchy is shown below (all the
         classes live in the <code class="literal">org.jboss.aop.array</code> package):
      </p>
               <p>
         
               </p>
               <pre class="programlisting">
    
ArrayElementInvocation
-ArrayElementReadInvocation
--BooleanArrayElementReadInvocation  -Element read from a boolean[]
--ByteArrayElementReadInvocation     -Element read from a byte[]
--CharArrayElementReadInvocation     -Element read from a char[]
--DoubleArrayElementReadInvocation   -Element read from a double[]
--FloatArrayElementReadInvocation    -Element read from a float[]
--IntArrayElementReadInvocation      -Element read from a int[]
--LongArrayElementReadInvocation     -Element read from a long[]
--ObjectArrayElementReadInvocation   -Element read from a Object[], String[] etc.
--ShortArrayElementReadInvocation    -Element read from a shore[]
-ArrayElementWriteInvocation
--BooleanArrayElementWriteInvocation -Element written to a boolean[]
--ByteArrayElementWriteInvocation    -Element written to a byte[]
--CharArrayElementWriteInvocation    -Element written to a char[]
--DoubleArrayElementWriteInvocation  -Element written to a double[]
--FloatArrayElementWriteInvocation   -Element written to a float[]
--IntArrayElementWriteInvocation     -Element written to a int[]
--LongArrayElementWriteInvocation    -Element written to a long[]
--ObjectArrayElementWriteInvocation  -Element written to a Object[], String[] etc.
--ShortArrayElementWriteInvocation   -Element written to a short[]

         </pre>
               <p>
      
               </p>
               <p>
         The write invocation classes allow you access to the value the element is being set to.
         <code class="literal">ArrayElementReadInvocation</code> defines a method to get hold of the value being
         set:
      </p>
               <p>
         
               </p>
               <pre class="programlisting">

   public abstract Object getValue();    

         </pre>
               <p>
      
               </p>
               <p>
         The sub-classes override this value, and also define a more fine-grained value to avoid using the
         wrapper classes where appropriate, as shown in the following methods from 
         <code class="literal">DoubleArrayElementWriteInvocation</code>:
      </p>
               <p>
         
               </p>
               <pre class="programlisting">

   public Object getValue()
   {
      return new Double(value);
   }

   public double getDoubleValue()
   {
      return value;
   }

         </pre>
               <p>
      
               </p>
               <p>
         When reading an array element the invocation's return value contains the value read. For all 
         array invocations you can get the index of the element being accessed by calling
         <code class="literal">ArrayElementInvocation.getIndex()</code>. 
      </p>
            </div>
         </div>
         <div class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title">
                        <a id="insrumentation-modes"/>Chapter 14. Instrumentation Modes</h2>
                  </div>
               </div>
            </div>
            <div class="toc">
               <dl>
                  <dt>
                     <span class="sect1">
                        <a href="#instrumention-modes-classic">14.1. Classic Weaving</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#instrumentation-modes-classic-not-optimized">14.1.1. Non-optimized</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#instrumentation-modes-classic-optimized">14.1.2. Optimized</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
                  <dt>
                     <span class="sect1">
                        <a href="#instrumention-modes-generated-advisor">14.2. Generated Advisor Weaving</a>
                     </span>
                  </dt>
                  <dd>
                     <dl>
                        <dt>
                           <span class="sect2">
                              <a href="#instrumention-modes-generated-advisor-batf">14.2.1. Lightweight Aspects</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#instrumention-modes-generated-advisor-instance-api">14.2.2. Improved Instance API</a>
                           </span>
                        </dt>
                        <dt>
                           <span class="sect2">
                              <a href="#instrumention-modes-generated-advisor-chain-overriding">14.2.3. Chain Overriding of Inherited Methods</a>
                           </span>
                        </dt>
                     </dl>
                  </dd>
               </dl>
            </div>
            <p>
         Since it's inception JBoss AOP has introduced different modes of weaving. While
         the base functionality is the same, the weaving mode introduced in JBoss AOP 2.0.0 allows
         for more functionality. This chapter will explain a bit about the pros and cons of 
         the different weaving modes, and what functionalities are offered.
   </p>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="instrumention-modes-classic"/>14.1. Classic Weaving</h2>
                     </div>
                  </div>
               </div>
               <p>
         This original weaving mode offers the full basic functionality, and comes in two
         flavours: 'non-optimized' and 'optimized'.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="instrumentation-modes-classic-not-optimized"/>14.1.1. Non-optimized</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            This is the original weaving mode. It generates a minimum amount of woven code, only 
            modyfying the target joinpoints. However, the the invocation classes end up calling
            the target joinpoint using reflection. Hence it will have minimum overhead at weaving
          time, but incur the extra cost of calling via reflection at runtime. 
         </p>
                  <p>
            To use not-optimized classic weaving at compile-time, you need to specify the following 
            parameters to the <code class="literal">aopc</code> ant task.
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
                           <code class="literal">optimized</code> - false</li>
                        <li>
                           <code class="literal">jboss.aop.instrumentor</code> - org.jboss.aop.instrument.ClassicInstrumentor</li>
                     </ul>
                  </div>
                  <p>
            An example is shown in the following build.xml snippet. Only the relevant parts are shown.
         </p>
                  <pre class="programlisting">
   &lt;aopc optimized="false" compilerclasspathref="..."&gt;
      &lt;sysproperty key="jboss.aop.instrumentor" \
         value="org.jboss.aop.instrument.ClassicInstrumentor"/&gt;
      ...
   &lt;/aopc&gt;
                  
         </pre>
                  <p>
            To turn this weaving mode on when using load-time weaving, you need to specify the same flags
            as system properties when running your woven application. Here is an example:
         </p>
                  <pre class="programlisting">
   java -Djboss.aop.optimized=false \
      -Djboss.aop.instrumentor=org.jboss.aop.instrument.ClassicInstrumentor \
      [other aop and classpath settings] MyClass
         </pre>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="instrumentation-modes-classic-optimized"/>14.1.2. Optimized</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            This is a development of the original weaving mode. Like the non-optimized flavour, it 
            modifies the target joinpoints, but in addition it generates an invocation class per woven
            joinpoint, which calls the target joinpoint normally, avoiding the cost of calling via 
            reflection. 
         </p>
                  <p>
            To use optimized classic weaving at compile-time, you need to specify the following 
            parameters to the <code class="literal">aopc</code> ant task.
         </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>
                           <code class="literal">optimized</code> - true</li>
                        <li>
                           <code class="literal">jboss.aop.instrumentor</code> - org.jboss.aop.instrument.ClassicInstrumentor</li>
                     </ul>
                  </div>
                  <p>
            An example is shown in the following build.xml snippet. Only the relevant parts are shown.
         </p>
                  <pre class="programlisting">
   &lt;aopc optimized="true" compilerclasspathref="..."&gt;
      &lt;sysproperty key="jboss.aop.instrumentor" \
         value="org.jboss.aop.instrument.ClassicInstrumentor"/&gt;
      ...
   &lt;/aopc&gt;
                  
         </pre>
                  <p>
            To turn this weaving mode on when using load-time weaving, you need to specify the same flags
            as system properties when running your woven application. Here is an example:
         </p>
                  <pre class="programlisting">
   java -Djboss.aop.optimized=true \
      -Djboss.aop.instrumentor=org.jboss.aop.instrument.ClassicInstrumentor \
      [other aop and classpath settings] MyClass
         </pre>
               </div>
            </div>
            <div class="sect1" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title">
                           <a id="instrumention-modes-generated-advisor"/>14.2. Generated Advisor Weaving</h2>
                     </div>
                  </div>
               </div>
               <p>
         This is the weaving mode that is used by default in JBoss AOP 2.0.x. In addition to generating
         the invocation classes, it also generates the 'advisors'. These contain the internal 
         book-keeping code that keeps track of the advice chains for the varoius woven joinpoints). 
         At runtime, this means that there is less overhead of looking things up. This mode also allows
         for some new features in JBoss AOP 2.0.x. 
      </p>
               <p>
         This weaving mode is used by default, so you don't have to specify any extra parameters. This may
         change in future, so for completeness the parameter you would to pass in to the <code class="literal">aopc</code> 
         ant task is.
      </p>
               <div class="itemizedlist">
                  <ul>
                     <li>
                        <code class="literal">jboss.aop.instrumentor</code> - org.jboss.aop.instrument.GeneratedAdvisorInstrumentor</li>
                  </ul>
               </div>
               <p>
         An example is shown in the following build.xml snippet. Only the relevant parts are shown.
      </p>
               <pre class="programlisting">
   &lt;aopc optimized="true" compilerclasspathref="..."&gt;
      &lt;sysproperty key="jboss.aop.instrumentor" \
         value="org.jboss.aop.instrument.GeneratedAdvisorInstrumentor"/&gt;
      ...
   &lt;/aopc&gt;
                  
      </pre>
               <p>
         Similarly, for load-time weaving, the default is to use this weaving mode. If you were to need
         to turn it one you would pass in the <code class="literal">GeneratedAdvisorInstrumentor</code> when
         starting the JVM:
      </p>
               <pre class="programlisting">
   java -Djboss.aop.instrumentor=org.jboss.aop.instrument.GeneratedAdvisorInstrumentor \
      [other aop and classpath settings] MyClass
      </pre>
               <p>
      Now we will look at some of the features that are available using this weaving mode.
      </p>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="instrumention-modes-generated-advisor-batf"/>14.2.1. Lightweight Aspects</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            The use of the before, after, after-throwing and finally advices as mentioned in 
            <a href="#adv-batf" title="4.2. Before/After/After-Throwing/Finally Advices">Section 4.2, “Before/After/After-Throwing/Finally Advices”</a> is only supported in this weaving mode.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="instrumention-modes-generated-advisor-instance-api"/>14.2.2. Improved Instance API</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            The improved instance api mentioned in <a href="#dyn-4" title="7.4. Improved Instance API">Section 7.4, “Improved Instance API”</a> is only available in this weaving mode.
         </p>
               </div>
               <div class="sect2" lang="en">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title">
                              <a id="instrumention-modes-generated-advisor-chain-overriding"/>14.2.3. Chain Overriding of Inherited Methods</h3>
                        </div>
                     </div>
                  </div>
                  <p>
            This will be explained with an example. Consider the following case:
         </p>
                  <pre class="programlisting">
   public class Base{
      void test(){}
   }

   public class Child{
   }

   public class ChildTest{
      void test(){}
   }
               
         </pre>
                  <pre class="programlisting">
   &lt;aop&gt;
      &lt;prepare expr="execution(* POJO-&gt;test())"/&gt;
      &lt;bind pointcut="execution(* Base-&gt;test())"&gt;
         &lt;interceptor class="BaseInterceptor"/&gt;
      &lt;/bind&gt;
      &lt;bind pointcut="execution(* Child*-&gt;test())"&gt;
         &lt;interceptor class="ChildInterceptor"/&gt;
      &lt;/bind&gt;
   &lt;/aop&gt;
   
         </pre>
                  <pre class="programlisting">

Base base = new Base();                  //1
Child child = new Child();               //2
ChildTest childTest = new ChildTest();   //3

base.test();                             //4
child.test();                            //5
childTest.test();                        //6

         </pre>
                  <p>
            With the "old" weaving we needed an exact match on methods for advices to get bound, meaning that:
            </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>Call 4 would get intercepted by BaseInterceptor</li>
                        <li>Call 5 would get intercepted by BaseInterceptor</li>
                        <li>Call 6 would get intercepted by ChildInterceptor</li>
                     </ul>
                  </div>
                  <p>
            The discrepancy is between calls 5 and 6, we get different behaviour depending on if we have overridden 
            the method or are just inheriting it, which in turn means we have to have some in-depth knowledge about 
            our hierarchy of classes and who overrides/inherits what in order to have predictable interception.
         </p>
                  <p>
            The new weaving model matches differently, and treats inherited methods the same as overridden methods, so:
            </p>
                  <div class="itemizedlist">
                     <ul>
                        <li>Call 4 would get intercepted by BaseInterceptor</li>
                        <li>Call 5 would get intercepted by ChildInterceptor</li>
                        <li>Call 6 would get intercepted by ChildInterceptor</li>
                     </ul>
                  </div>
                  <p>
         
                  </p>
                  <p>
            Note that for this to work, the parent method <span class="emphasis">
                        <em>MUST</em>
                     </span> be woven. In the previous example
            <code class="literal">Base.test()</code> has been prepared.
         </p>
               </div>
            </div>
         </div>
      </div>
   </body>
</html>